{"version":3,"file":"core.umd.js","sources":["../../../../../../../../../../../../../../../Users/misko/work/angular/node_modules/tslib/tslib.es6.js","../../../../../../../../../../execroot/angular/packages/core/src/di/defs.ts","../../../../../../../../../../execroot/angular/packages/core/src/di/injection_token.ts","../../../../../../../../../../execroot/angular/packages/core/src/util/decorators.ts","../../../../../../../../../../execroot/angular/packages/core/src/metadata/di.ts","../../../../../../../../../../execroot/angular/packages/core/src/change_detection/constants.ts","../../../../../../../../../../execroot/angular/packages/core/src/metadata/directives.ts","../../../../../../../../../../execroot/angular/packages/core/src/type.ts","../../../../../../../../../../execroot/angular/packages/core/src/util.ts","../../../../../../../../../../execroot/angular/packages/core/src/reflection/reflection_capabilities.ts","../../../../../../../../../../execroot/angular/packages/core/src/util/property.ts","../../../../../../../../../../execroot/angular/packages/core/src/di/forward_ref.ts","../../../../../../../../../../execroot/angular/packages/core/src/di/metadata.ts","../../../../../../../../../../execroot/angular/packages/core/src/di/injector.ts","../../../../../../../../../../execroot/angular/packages/core/src/di/injectable.ts","../../../../../../../../../../execroot/angular/packages/core/src/metadata/ng_module.ts","../../../../../../../../../../execroot/angular/packages/core/src/metadata/view.ts","../../../../../../../../../../execroot/angular/packages/core/src/metadata.ts","../../../../../../../../../../execroot/angular/packages/core/src/version.ts","../../../../../../../../../../execroot/angular/packages/core/src/errors.ts","../../../../../../../../../../execroot/angular/packages/core/src/error_handler.ts","../../../../../../../../../../execroot/angular/packages/core/src/di/reflective_errors.ts","../../../../../../../../../../execroot/angular/packages/core/src/di/reflective_key.ts","../../../../../../../../../../execroot/angular/packages/core/src/reflection/reflector.ts","../../../../../../../../../../execroot/angular/packages/core/src/reflection/reflection.ts","../../../../../../../../../../execroot/angular/packages/core/src/di/reflective_provider.ts","../../../../../../../../../../execroot/angular/packages/core/src/di/reflective_injector.ts","../../../../../../../../../../execroot/angular/packages/core/src/di/scope.ts","../../../../../../../../../../execroot/angular/packages/core/src/di/r3_injector.ts","../../../../../../../../../../execroot/angular/packages/core/src/di.ts","../../../../../../../../../../execroot/angular/packages/core/src/util/lang.ts","../../../../../../../../../../execroot/angular/packages/core/src/application_init.ts","../../../../../../../../../../execroot/angular/packages/core/src/application_tokens.ts","../../../../../../../../../../execroot/angular/packages/core/src/console.ts","../../../../../../../../../../execroot/angular/packages/core/src/linker/compiler.ts","../../../../../../../../../../execroot/angular/packages/core/src/linker/component_factory.ts","../../../../../../../../../../execroot/angular/packages/core/src/linker/component_factory_resolver.ts","../../../../../../../../../../execroot/angular/packages/core/src/linker/ng_module_factory.ts","../../../../../../../../../../execroot/angular/packages/core/src/profile/wtf_impl.ts","../../../../../../../../../../execroot/angular/packages/core/src/profile/profile.ts","../../../../../../../../../../execroot/angular/packages/core/src/event_emitter.ts","../../../../../../../../../../execroot/angular/packages/core/src/zone/ng_zone.ts","../../../../../../../../../../execroot/angular/packages/core/src/testability/testability.ts","../../../../../../../../../../execroot/angular/packages/core/src/application_ref.ts","../../../../../../../../../../execroot/angular/packages/core/src/zone.ts","../../../../../../../../../../execroot/angular/packages/core/src/render/api.ts","../../../../../../../../../../execroot/angular/packages/core/src/render.ts","../../../../../../../../../../execroot/angular/packages/core/src/linker/element_ref.ts","../../../../../../../../../../execroot/angular/packages/core/src/linker/ng_module_factory_loader.ts","../../../../../../../../../../execroot/angular/packages/core/src/linker/query_list.ts","../../../../../../../../../../execroot/angular/packages/core/src/linker/system_js_ng_module_factory_loader.ts","../../../../../../../../../../execroot/angular/packages/core/src/linker/template_ref.ts","../../../../../../../../../../execroot/angular/packages/core/src/linker/view_container_ref.ts","../../../../../../../../../../execroot/angular/packages/core/src/change_detection/change_detector_ref.ts","../../../../../../../../../../execroot/angular/packages/core/src/linker/view_ref.ts","../../../../../../../../../../execroot/angular/packages/core/src/linker.ts","../../../../../../../../../../execroot/angular/packages/core/src/debug/debug_node.ts","../../../../../../../../../../execroot/angular/packages/core/src/change_detection/change_detection_util.ts","../../../../../../../../../../execroot/angular/packages/core/src/change_detection/differs/default_iterable_differ.ts","../../../../../../../../../../execroot/angular/packages/core/src/change_detection/differs/default_keyvalue_differ.ts","../../../../../../../../../../execroot/angular/packages/core/src/change_detection/differs/iterable_differs.ts","../../../../../../../../../../execroot/angular/packages/core/src/change_detection/differs/keyvalue_differs.ts","../../../../../../../../../../execroot/angular/packages/core/src/change_detection/change_detection.ts","../../../../../../../../../../execroot/angular/packages/core/src/change_detection.ts","../../../../../../../../../../execroot/angular/packages/core/src/platform_core_providers.ts","../../../../../../../../../../execroot/angular/packages/core/src/i18n/tokens.ts","../../../../../../../../../../execroot/angular/packages/core/src/application_module.ts","../../../../../../../../../../execroot/angular/packages/core/src/sanitization/inert_body.ts","../../../../../../../../../../execroot/angular/packages/core/src/sanitization/url_sanitizer.ts","../../../../../../../../../../execroot/angular/packages/core/src/sanitization/html_sanitizer.ts","../../../../../../../../../../execroot/angular/packages/core/src/sanitization/style_sanitizer.ts","../../../../../../../../../../execroot/angular/packages/core/src/sanitization/security.ts","../../../../../../../../../../execroot/angular/packages/core/src/view/types.ts","../../../../../../../../../../execroot/angular/packages/core/src/view/errors.ts","../../../../../../../../../../execroot/angular/packages/core/src/view/util.ts","../../../../../../../../../../execroot/angular/packages/core/src/view/element.ts","../../../../../../../../../../execroot/angular/packages/core/src/view/ng_module.ts","../../../../../../../../../../execroot/angular/packages/core/src/view/view_attach.ts","../../../../../../../../../../execroot/angular/packages/core/src/view/refs.ts","../../../../../../../../../../execroot/angular/packages/core/src/view/provider.ts","../../../../../../../../../../execroot/angular/packages/core/src/view/query.ts","../../../../../../../../../../execroot/angular/packages/core/src/view/ng_content.ts","../../../../../../../../../../execroot/angular/packages/core/src/view/pure_expression.ts","../../../../../../../../../../execroot/angular/packages/core/src/view/text.ts","../../../../../../../../../../execroot/angular/packages/core/src/view/view.ts","../../../../../../../../../../execroot/angular/packages/core/src/view/services.ts","../../../../../../../../../../execroot/angular/packages/core/src/view/entrypoint.ts","../../../../../../../../../../execroot/angular/packages/core/src/view/index.ts","../../../../../../../../../../execroot/angular/packages/core/src/core_private_export.ts","../../../../../../../../../../execroot/angular/packages/core/src/render3/assert.ts","../../../../../../../../../../execroot/angular/packages/core/src/render3/hooks.ts","../../../../../../../../../../execroot/angular/packages/core/src/render3/ng_dev_mode.ts","../../../../../../../../../../execroot/angular/packages/core/src/render3/interfaces/projection.ts","../../../../../../../../../../execroot/angular/packages/core/src/render3/node_assert.ts","../../../../../../../../../../execroot/angular/packages/core/src/render3/interfaces/container.ts","../../../../../../../../../../execroot/angular/packages/core/src/render3/interfaces/node.ts","../../../../../../../../../../execroot/angular/packages/core/src/render3/interfaces/renderer.ts","../../../../../../../../../../execroot/angular/packages/core/src/render3/interfaces/view.ts","../../../../../../../../../../execroot/angular/packages/core/src/render3/util.ts","../../../../../../../../../../execroot/angular/packages/core/src/render3/node_manipulation.ts","../../../../../../../../../../execroot/angular/packages/core/src/render3/node_selector_matcher.ts","../../../../../../../../../../execroot/angular/packages/core/src/render3/errors.ts","../../../../../../../../../../execroot/angular/packages/core/src/render3/instructions.ts","../../../../../../../../../../execroot/angular/packages/core/src/render3/view_ref.ts","../../../../../../../../../../execroot/angular/packages/core/src/render3/component.ts","../../../../../../../../../../execroot/angular/packages/core/src/render3/di.ts","../../../../../../../../../../execroot/angular/packages/core/src/render3/definition.ts","../../../../../../../../../../execroot/angular/packages/core/src/render3/pure_function.ts","../../../../../../../../../../execroot/angular/packages/core/src/render3/pipe.ts","../../../../../../../../../../execroot/angular/packages/core/src/render3/interfaces/definition.ts","../../../../../../../../../../execroot/angular/packages/core/src/render3/interfaces/injector.ts","../../../../../../../../../../execroot/angular/packages/core/src/render3/interfaces/query.ts","../../../../../../../../../../execroot/angular/packages/core/src/render3/query.ts","../../../../../../../../../../execroot/angular/packages/core/src/render3/index.ts","../../../../../../../../../../execroot/angular/packages/core/src/sanitization/sanitization.ts","../../../../../../../../../../execroot/angular/packages/core/src/core_render3_private_export.ts","../../../../../../../../../../execroot/angular/packages/core/src/codegen_private_exports.ts","../../../../../../../../../../execroot/angular/packages/core/src/core.ts","../../../../../../../../../../execroot/angular/packages/core/public_api.ts","../../../../../../../../../../execroot/angular/packages/core/index.ts","../../../../../../../../../../execroot/angular/packages/core/core.ts"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = Object.setPrototypeOf ||\r\n    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = Object.assign || function __assign(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n    }\r\n    return t;\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [0, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { if (o[n]) i[n] = function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; }; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator];\r\n    return m ? m.call(o) : typeof __values === \"function\" ? __values(o) : o[Symbol.iterator]();\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Type} from '../type';\n\nimport {ClassProvider, ClassSansProvider, ConstructorProvider, ConstructorSansProvider, ExistingProvider, ExistingSansProvider, FactoryProvider, FactorySansProvider, StaticClassProvider, StaticClassSansProvider, ValueProvider, ValueSansProvider} from './provider';\n\n/**\n * Information about how a type or `InjectionToken` interfaces with the DI system.\n *\n * At a minimum, this includes a `factory` which defines how to create the given type `T`, possibly\n * requesting injection of other types if necessary.\n *\n * Optionally, a `providedIn` parameter specifies that the given type belongs to a particular\n * `InjectorDef`, `NgModule`, or a special scope (e.g. `'root'`). A value of `null` indicates\n * that the injectable does not belong to any scope.\n *\n * NOTE: This is a private type and should not be exported\n */\nexport interface InjectableDef<T> {\n  /**\n   * Specifies that the given type belongs to a particular injector:\n   * - `InjectorType` such as `NgModule`,\n   * - `'root'` the root injector\n   * - `'any'` all injectors.\n   * - `null`, does not belong to any injector. Must be explicitly listed in the injector\n   *   `providers`.\n   */\n  providedIn: InjectorType<any>|'root'|'any'|null;\n\n  /**\n   * Factory method to execute to create an instance of the injectable.\n   */\n  factory: () => T;\n\n  /**\n   * In a case of no explicit injector, a location where the instance of the injectable is stored.\n   */\n  value: T|undefined;\n}\n\n/**\n * Information about the providers to be included in an `Injector` as well as how the given type\n * which carries the information should be created by the DI system.\n *\n * An `InjectorDef` can import other types which have `InjectorDefs`, forming a deep nested\n * structure of providers with a defined priority (identically to how `NgModule`s also have\n * an import/dependency structure).\n *\n * NOTE: This is a private type and should not be exported\n */\nexport interface InjectorDef<T> {\n  factory: () => T;\n\n  // TODO(alxhub): Narrow down the type here once decorators properly change the return type of the\n  // class they are decorating (to add the ngInjectableDef property for example).\n  providers: (Type<any>|ValueProvider|ExistingProvider|FactoryProvider|ConstructorProvider|\n              StaticClassProvider|ClassProvider|any[])[];\n\n  imports: (InjectorType<any>|InjectorTypeWithProviders<any>)[];\n}\n\n/**\n * A `Type` which has an `InjectableDef` static field.\n *\n * `InjectableDefType`s contain their own Dependency Injection metadata and are usable in an\n * `InjectorDef`-based `StaticInjector.\n *\n * @experimental\n */\nexport interface InjectableType<T> extends Type<T> {\n  /**\n   * Opaque type whose structure is highly version dependent. Do not rely on any properties.\n   */\n  ngInjectableDef: never;\n}\n\n/**\n * A type which has an `InjectorDef` static field.\n *\n * `InjectorDefTypes` can be used to configure a `StaticInjector`.\n *\n * @experimental\n */\nexport interface InjectorType<T> extends Type<T> {\n  /**\n   * Opaque type whose structure is highly version dependent. Do not rely on any properties.\n   */\n  ngInjectorDef: never;\n}\n\n/**\n * Describes the `InjectorDef` equivalent of a `ModuleWithProviders`, an `InjectorDefType` with an\n * associated array of providers.\n *\n * Objects of this type can be listed in the imports section of an `InjectorDef`.\n *\n * NOTE: This is a private type and should not be exported\n */\nexport interface InjectorTypeWithProviders<T> {\n  ngModule: InjectorType<T>;\n  providers?: (Type<any>|ValueProvider|ExistingProvider|FactoryProvider|ConstructorProvider|\n               StaticClassProvider|ClassProvider|any[])[];\n}\n\n\n/**\n * Construct an `InjectableDef` which defines how a token will be constructed by the DI system, and\n * in which injectors (if any) it will be available.\n *\n * This should be assigned to a static `ngInjectableDef` field on a type, which will then be an\n * `InjectableType`.\n *\n * Options:\n * * `providedIn` determines which injectors will include the injectable, by either associating it\n *   with an `@NgModule` or other `InjectorType`, or by specifying that this injectable should be\n *   provided in the `'root'` injector, which will be the application-level injector in most apps.\n * * `factory` gives the zero argument function which will create an instance of the injectable.\n *   The factory can call `inject` to access the `Injector` and request injection of dependencies.\n *\n * @experimental\n */\nexport function defineInjectable<T>(opts: {\n  providedIn?: Type<any>| 'root' | 'any' | null,\n  factory: () => T,\n}): never {\n  return ({\n    providedIn: opts.providedIn as any || null, factory: opts.factory, value: undefined,\n  } as InjectableDef<T>) as never;\n}\n\n/**\n * Construct an `InjectorDef` which configures an injector.\n *\n * This should be assigned to a static `ngInjectorDef` field on a type, which will then be an\n * `InjectorType`.\n *\n * Options:\n *\n * * `factory`: an `InjectorType` is an instantiable type, so a zero argument `factory` function to\n *   create the type must be provided. If that factory function needs to inject arguments, it can\n *   use the `inject` function.\n * * `providers`: an optional array of providers to add to the injector. Each provider must\n *   either have a factory or point to a type which has an `ngInjectableDef` static property (the\n *   type must be an `InjectableType`).\n * * `imports`: an optional array of imports of other `InjectorType`s or `InjectorTypeWithModule`s\n *   whose providers will also be added to the injector. Locally provided types will override\n *   providers from imports.\n *\n * @experimental\n */\nexport function defineInjector(options: {factory: () => any, providers?: any[], imports?: any[]}):\n    never {\n  return ({\n    factory: options.factory, providers: options.providers || [], imports: options.imports || [],\n  } as InjectorDef<any>) as never;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Type} from '../type';\n\nimport {InjectableDef, defineInjectable} from './defs';\n\n/**\n * Creates a token that can be used in a DI Provider.\n *\n * Use an `InjectionToken` whenever the type you are injecting is not reified (does not have a\n * runtime representation) such as when injecting an interface, callable type, array or\n * parametrized type.\n *\n * `InjectionToken` is parameterized on `T` which is the type of object which will be returned by\n * the `Injector`. This provides additional level of type safety.\n *\n * ```\n * interface MyInterface {...}\n * var myInterface = injector.get(new InjectionToken<MyInterface>('SomeToken'));\n * // myInterface is inferred to be MyInterface.\n * ```\n *\n * When creating an `InjectionToken`, you can optionally specify a factory function which returns\n * (possibly by creating) a default value of the parameterized type `T`. This sets up the\n * `InjectionToken` using this factory as a provider as if it was defined explicitly in the\n * application's root injector. If the factory function, which takes zero arguments, needs to inject\n * dependencies, it can do so using the `inject` function. See below for an example.\n *\n * Additionally, if a `factory` is specified you can also specify the `providedIn` option, which\n * overrides the above behavior and marks the token as belonging to a particular `@NgModule`. As\n * mentioned above, `'root'` is the default value for `providedIn`.\n *\n * @usageNotes\n * ### Basic Example\n *\n * {@example core/di/ts/injector_spec.ts region='InjectionToken'}\n *\n * ### Tree-shakeable Example\n *\n * {@example core/di/ts/injector_spec.ts region='ShakeableInjectionToken'}\n *\n */\nexport class InjectionToken<T> {\n  /** @internal */\n  readonly ngMetadataName = 'InjectionToken';\n\n  readonly ngInjectableDef: never|undefined;\n\n  constructor(protected _desc: string, options?: {\n    providedIn?: Type<any>| 'root' | null,\n    factory: () => T\n  }) {\n    if (options !== undefined) {\n      this.ngInjectableDef = defineInjectable({\n        providedIn: options.providedIn || 'root',\n        factory: options.factory,\n      });\n    } else {\n      this.ngInjectableDef = undefined;\n    }\n  }\n\n  toString(): string { return `InjectionToken ${this._desc}`; }\n}\n\nexport interface InjectableDefToken<T> extends InjectionToken<T> { ngInjectableDef: never; }\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Type} from '../type';\n\n/**\n * An interface implemented by all Angular type decorators, which allows them to be used as ES7\n * decorators as well as\n * Angular DSL syntax.\n *\n * ES7 syntax:\n *\n * ```\n * @ng.Component({...})\n * class MyClass {...}\n * ```\n *\n */\nexport interface TypeDecorator {\n  /**\n   * Invoke as ES7 decorator.\n   */\n  <T extends Type<any>>(type: T): T;\n\n  // Make TypeDecorator assignable to built-in ParameterDecorator type.\n  // ParameterDecorator is declared in lib.d.ts as a `declare type`\n  // so we cannot declare this interface as a subtype.\n  // see https://github.com/angular/angular/issues/3379#issuecomment-126169417\n  (target: Object, propertyKey?: string|symbol, parameterIndex?: number): void;\n}\n\nexport const ANNOTATIONS = '__annotations__';\nexport const PARAMETERS = '__parameters__';\nexport const PROP_METADATA = '__prop__metadata__';\n\n/**\n * @suppress {globalThis}\n */\nexport function makeDecorator(\n    name: string, props?: (...args: any[]) => any, parentClass?: any,\n    chainFn?: (fn: Function) => void, typeFn?: (type: Type<any>, ...args: any[]) => void):\n    {new (...args: any[]): any; (...args: any[]): any; (...args: any[]): (cls: any) => any;} {\n  const metaCtor = makeMetadataCtor(props);\n\n  function DecoratorFactory(...args: any[]): (cls: any) => any {\n    if (this instanceof DecoratorFactory) {\n      metaCtor.call(this, ...args);\n      return this;\n    }\n\n    const annotationInstance = new (<any>DecoratorFactory)(...args);\n    const TypeDecorator: TypeDecorator = <TypeDecorator>function TypeDecorator(cls: Type<any>) {\n      typeFn && typeFn(cls, ...args);\n      // Use of Object.defineProperty is important since it creates non-enumerable property which\n      // prevents the property is copied during subclassing.\n      const annotations = cls.hasOwnProperty(ANNOTATIONS) ?\n          (cls as any)[ANNOTATIONS] :\n          Object.defineProperty(cls, ANNOTATIONS, {value: []})[ANNOTATIONS];\n      annotations.push(annotationInstance);\n      return cls;\n    };\n    if (chainFn) chainFn(TypeDecorator);\n    return TypeDecorator;\n  }\n\n  if (parentClass) {\n    DecoratorFactory.prototype = Object.create(parentClass.prototype);\n  }\n\n  DecoratorFactory.prototype.ngMetadataName = name;\n  (<any>DecoratorFactory).annotationCls = DecoratorFactory;\n  return DecoratorFactory as any;\n}\n\nfunction makeMetadataCtor(props?: (...args: any[]) => any): any {\n  return function ctor(...args: any[]) {\n    if (props) {\n      const values = props(...args);\n      for (const propName in values) {\n        this[propName] = values[propName];\n      }\n    }\n  };\n}\n\nexport function makeParamDecorator(\n    name: string, props?: (...args: any[]) => any, parentClass?: any): any {\n  const metaCtor = makeMetadataCtor(props);\n  function ParamDecoratorFactory(...args: any[]): any {\n    if (this instanceof ParamDecoratorFactory) {\n      metaCtor.apply(this, args);\n      return this;\n    }\n    const annotationInstance = new (<any>ParamDecoratorFactory)(...args);\n\n    (<any>ParamDecorator).annotation = annotationInstance;\n    return ParamDecorator;\n\n    function ParamDecorator(cls: any, unusedKey: any, index: number): any {\n      // Use of Object.defineProperty is important since it creates non-enumerable property which\n      // prevents the property is copied during subclassing.\n      const parameters = cls.hasOwnProperty(PARAMETERS) ?\n          (cls as any)[PARAMETERS] :\n          Object.defineProperty(cls, PARAMETERS, {value: []})[PARAMETERS];\n\n      // there might be gaps if some in between parameters do not have annotations.\n      // we pad with nulls.\n      while (parameters.length <= index) {\n        parameters.push(null);\n      }\n\n      (parameters[index] = parameters[index] || []).push(annotationInstance);\n      return cls;\n    }\n  }\n  if (parentClass) {\n    ParamDecoratorFactory.prototype = Object.create(parentClass.prototype);\n  }\n  ParamDecoratorFactory.prototype.ngMetadataName = name;\n  (<any>ParamDecoratorFactory).annotationCls = ParamDecoratorFactory;\n  return ParamDecoratorFactory;\n}\n\nexport function makePropDecorator(\n    name: string, props?: (...args: any[]) => any, parentClass?: any): any {\n  const metaCtor = makeMetadataCtor(props);\n\n  function PropDecoratorFactory(...args: any[]): any {\n    if (this instanceof PropDecoratorFactory) {\n      metaCtor.apply(this, args);\n      return this;\n    }\n\n    const decoratorInstance = new (<any>PropDecoratorFactory)(...args);\n\n    return function PropDecorator(target: any, name: string) {\n      const constructor = target.constructor;\n      // Use of Object.defineProperty is important since it creates non-enumerable property which\n      // prevents the property is copied during subclassing.\n      const meta = constructor.hasOwnProperty(PROP_METADATA) ?\n          (constructor as any)[PROP_METADATA] :\n          Object.defineProperty(constructor, PROP_METADATA, {value: {}})[PROP_METADATA];\n      meta[name] = meta.hasOwnProperty(name) && meta[name] || [];\n      meta[name].unshift(decoratorInstance);\n    };\n  }\n\n  if (parentClass) {\n    PropDecoratorFactory.prototype = Object.create(parentClass.prototype);\n  }\n\n  PropDecoratorFactory.prototype.ngMetadataName = name;\n  (<any>PropDecoratorFactory).annotationCls = PropDecoratorFactory;\n  return PropDecoratorFactory;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {InjectionToken} from '../di/injection_token';\nimport {Type} from '../type';\nimport {makeParamDecorator, makePropDecorator} from '../util/decorators';\n\n/**\n * This token can be used to create a virtual provider that will populate the\n * `entryComponents` fields of components and ng modules based on its `useValue`.\n * All components that are referenced in the `useValue` value (either directly\n * or in a nested array or map) will be added to the `entryComponents` property.\n *\n * @usageNotes\n * ### Example\n * The following example shows how the router can populate the `entryComponents`\n * field of an NgModule based on the router configuration which refers\n * to components.\n *\n * ```typescript\n * // helper function inside the router\n * function provideRoutes(routes) {\n *   return [\n *     {provide: ROUTES, useValue: routes},\n *     {provide: ANALYZE_FOR_ENTRY_COMPONENTS, useValue: routes, multi: true}\n *   ];\n * }\n *\n * // user code\n * let routes = [\n *   {path: '/root', component: RootComp},\n *   {path: '/teams', component: TeamsComp}\n * ];\n *\n * @NgModule({\n *   providers: [provideRoutes(routes)]\n * })\n * class ModuleWithRoutes {}\n * ```\n *\n * @experimental\n */\nexport const ANALYZE_FOR_ENTRY_COMPONENTS = new InjectionToken<any>('AnalyzeForEntryComponents');\n\n/**\n * Type of the Attribute decorator / constructor function.\n *\n *\n */\nexport interface AttributeDecorator {\n  /**\n   * Specifies that a constant attribute value should be injected.\n   *\n   * The directive can inject constant string literals of host element attributes.\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * Suppose we have an `<input>` element and want to know its `type`.\n   *\n   * ```html\n   * <input type=\"text\">\n   * ```\n   *\n   * A decorator can inject string literal `text` like so:\n   *\n   * {@example core/ts/metadata/metadata.ts region='attributeMetadata'}\n   *\n   * ### Example as TypeScript Decorator\n   *\n   * {@example core/ts/metadata/metadata.ts region='attributeFactory'}\n   *\n   * ### Example as ES5 annotation\n   *\n   * ```\n   * var MyComponent = function(title) {\n   *   ...\n   * };\n   *\n   * MyComponent.annotations = [\n   *   new ng.Component({...})\n   * ]\n   * MyComponent.parameters = [\n   *   [new ng.Attribute('title')]\n   * ]\n   * ```\n   *\n   *\n   */\n  (name: string): any;\n  new (name: string): Attribute;\n}\n\n\n/**\n * Type of the Attribute metadata.\n */\nexport interface Attribute { attributeName?: string; }\n\n/**\n * Attribute decorator and metadata.\n *\n * @Annotation\n */\nexport const Attribute: AttributeDecorator =\n    makeParamDecorator('Attribute', (attributeName?: string) => ({attributeName}));\n\n/**\n * Type of the Query metadata.\n */\nexport interface Query {\n  descendants: boolean;\n  first: boolean;\n  read: any;\n  isViewQuery: boolean;\n  selector: any;\n}\n\n/**\n * Base class for query metadata.\n *\n * @see `ContentChildren`.\n * @see `ContentChild`.\n * @see `ViewChildren`.\n * @see `ViewChild`.\n */\nexport abstract class Query {}\n\n/**\n * Type of the ContentChildren decorator / constructor function.\n *\n * @see `ContentChildren`.\n */\nexport interface ContentChildrenDecorator {\n  /**\n   * Configures a content query.\n   *\n   * You can use ContentChildren to get the `QueryList` of elements or directives from the\n   * content DOM. Any time a child element is added, removed, or moved, the query list will be\n   * updated, and the changes observable of the query list will emit a new value.\n   *\n   * Content queries are set before the `ngAfterContentInit` callback is called.\n   *\n   * **Metadata Properties**:\n   *\n   * * **selector** - the directive type or the name used for querying.\n   * * **descendants** - include only direct children or all descendants.\n   * * **read** - read a different token from the queried elements.\n   *\n   * @usageNotes\n   * ### Basic Example\n   *\n   * Here is a simple demonstration of how the `ContentChildren` decorator can be used.\n   *\n   * {@example core/di/ts/contentChildren/content_children_howto.ts region='HowTo'}\n   *\n   * ### Tab-pane Example\n   *\n   * Here is a slightly more realistic example that shows how `ContentChildren` decorators\n   * can be used to implement a tab pane component.\n   *\n   * {@example core/di/ts/contentChildren/content_children_example.ts region='Component'}\n   *\n   * @Annotation\n   */\n  (selector: Type<any>|Function|string, opts?: {descendants?: boolean, read?: any}): any;\n  new (selector: Type<any>|Function|string, opts?: {descendants?: boolean, read?: any}): Query;\n}\n\n/**\n * Type of the ContentChildren metadata.\n *\n *\n * @Annotation\n */\nexport type ContentChildren = Query;\n\n/**\n * ContentChildren decorator and metadata.\n *\n *\n *  @Annotation\n */\nexport const ContentChildren: ContentChildrenDecorator = makePropDecorator(\n    'ContentChildren',\n    (selector?: any, data: any = {}) =>\n        ({selector, first: false, isViewQuery: false, descendants: false, ...data}),\n    Query);\n\n/**\n * Type of the ContentChild decorator / constructor function.\n *\n *\n *\n */\nexport interface ContentChildDecorator {\n  /**\n   * Configures a content query.\n   *\n   * You can use ContentChild to get the first element or the directive matching the selector from\n   * the content DOM. If the content DOM changes, and a new child matches the selector,\n   * the property will be updated.\n   *\n   * Content queries are set before the `ngAfterContentInit` callback is called.\n   *\n   * **Metadata Properties**:\n   *\n   * * **selector** - the directive type or the name used for querying.\n   * * **read** - read a different token from the queried element.\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * {@example core/di/ts/contentChild/content_child_howto.ts region='HowTo'}\n   *\n   * ### Example\n   *\n   * {@example core/di/ts/contentChild/content_child_example.ts region='Component'}\n   *\n   * @Annotation\n   */\n  (selector: Type<any>|Function|string, opts?: {read?: any}): any;\n  new (selector: Type<any>|Function|string, opts?: {read?: any}): ContentChild;\n}\n\n/**\n * Type of the ContentChild metadata.\n *\n * @see `ContentChild`.\n *\n *\n */\nexport type ContentChild = Query;\n\n/**\n * ContentChild decorator and metadata.\n *\n *\n * @Annotation\n */\nexport const ContentChild: ContentChildDecorator = makePropDecorator(\n    'ContentChild', (selector?: any, data: any = {}) =>\n                        ({selector, first: true, isViewQuery: false, descendants: true, ...data}),\n    Query);\n\n/**\n * Type of the ViewChildren decorator / constructor function.\n *\n * @see `ViewChildren`.\n *\n *\n */\nexport interface ViewChildrenDecorator {\n  /**\n   * Configures a view query.\n   *\n   * You can use ViewChildren to get the `QueryList` of elements or directives from the\n   * view DOM. Any time a child element is added, removed, or moved, the query list will be updated,\n   * and the changes observable of the query list will emit a new value.\n   *\n   * View queries are set before the `ngAfterViewInit` callback is called.\n   *\n   * **Metadata Properties**:\n   *\n   * * **selector** - the directive type or the name used for querying.\n   * * **read** - read a different token from the queried elements.\n   *\n   * @usageNotes\n   *\n   * ### Example\n   *\n   * {@example core/di/ts/viewChildren/view_children_howto.ts region='HowTo'}\n   *\n   * ### Example\n   *\n   * {@example core/di/ts/viewChildren/view_children_example.ts region='Component'}\n   *\n   * @Annotation\n   */\n  (selector: Type<any>|Function|string, opts?: {read?: any}): any;\n  new (selector: Type<any>|Function|string, opts?: {read?: any}): ViewChildren;\n}\n\n/**\n * Type of the ViewChildren metadata.\n */\nexport type ViewChildren = Query;\n\n/**\n * ViewChildren decorator and metadata.\n *\n * @Annotation\n */\nexport const ViewChildren: ViewChildrenDecorator = makePropDecorator(\n    'ViewChildren', (selector?: any, data: any = {}) =>\n                        ({selector, first: false, isViewQuery: true, descendants: true, ...data}),\n    Query);\n\n/**\n * Type of the ViewChild decorator / constructor function.\n *\n * @see `ViewChild`.\n */\nexport interface ViewChildDecorator {\n  /**\n   * @description\n   * Configures a view query.\n   *\n   * You can use ViewChild to get the first element or the directive matching the selector from the\n   * view DOM. If the view DOM changes, and a new child matches the selector,\n   * the property will be updated.\n   *\n   * View queries are set before the `ngAfterViewInit` callback is called.\n   *\n   * **Metadata Properties**:\n   *\n   * * **selector** - the directive type or the name used for querying.\n   * * **read** - read a different token from the queried elements.\n   *\n   * @usageNotes\n   *\n   * ### Example\n   *\n   * {@example core/di/ts/viewChild/view_child_howto.ts region='HowTo'}\n   *\n   * ### Example\n   *\n   * {@example core/di/ts/viewChild/view_child_example.ts region='Component'}\n   *\n   * @Annotation\n   */\n  (selector: Type<any>|Function|string, opts?: {read?: any}): any;\n  new (selector: Type<any>|Function|string, opts?: {read?: any}): ViewChild;\n}\n\n/**\n * Type of the ViewChild metadata.\n */\nexport type ViewChild = Query;\n\n/**\n * ViewChild decorator and metadata.\n *\n * @Annotation\n */\nexport const ViewChild: ViewChildDecorator = makePropDecorator(\n    'ViewChild', (selector: any, data: any) =>\n                     ({selector, first: true, isViewQuery: true, descendants: true, ...data}),\n    Query);\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\n/**\n * Describes within the change detector which strategy will be used the next time change\n * detection is triggered.\n *\n */\nexport enum ChangeDetectionStrategy {\n  /**\n   * `OnPush` means that the change detector's mode will be initially set to `CheckOnce`.\n   */\n  OnPush = 0,\n\n  /**\n   * `Default` means that the change detector's mode will be initially set to `CheckAlways`.\n   */\n  Default = 1,\n}\n\n/**\n * Describes the status of the detector.\n */\nexport enum ChangeDetectorStatus {\n  /**\n   * `CheckOnce` means that after calling detectChanges the mode of the change detector\n   * will become `Checked`.\n   */\n  CheckOnce,\n\n  /**\n   * `Checked` means that the change detector should be skipped until its mode changes to\n   * `CheckOnce`.\n   */\n  Checked,\n\n  /**\n   * `CheckAlways` means that after calling detectChanges the mode of the change detector\n   * will remain `CheckAlways`.\n   */\n  CheckAlways,\n\n  /**\n   * `Detached` means that the change detector sub tree is not a part of the main tree and\n   * should be skipped.\n   */\n  Detached,\n\n  /**\n   * `Errored` means that the change detector encountered an error checking a binding\n   * or calling a directive lifecycle method and is now in an inconsistent state. Change\n   * detectors in this state will no longer detect changes.\n   */\n  Errored,\n\n  /**\n   * `Destroyed` means that the change detector is destroyed.\n   */\n  Destroyed,\n}\n\nexport function isDefaultChangeDetectionStrategy(changeDetectionStrategy: ChangeDetectionStrategy):\n    boolean {\n  return changeDetectionStrategy == null ||\n      changeDetectionStrategy === ChangeDetectionStrategy.Default;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ChangeDetectionStrategy} from '../change_detection/constants';\nimport {Provider} from '../di';\nimport {Type} from '../type';\nimport {TypeDecorator, makeDecorator, makePropDecorator} from '../util/decorators';\n\nimport {ViewEncapsulation} from './view';\n\n\n/**\n * Type of the Directive decorator / constructor function.\n */\nexport interface DirectiveDecorator {\n  /**\n   * Marks a class as an Angular directive and collects directive configuration\n   * metadata.\n   *\n   * Directive decorator allows you to mark a class as an Angular directive and provide additional\n   * metadata that determines how the directive should be processed, instantiated and used at\n   * runtime.\n   *\n   * Directives allow you to attach behavior to elements in the DOM..\n   *\n   * A directive must belong to an NgModule in order for it to be usable\n   * by another directive, component, or application. To specify that a directive is a member of an\n   * NgModule,\n   * you should list it in the `declarations` field of that NgModule.\n   *\n   * In addition to the metadata configuration specified via the Directive decorator,\n   * directives can control their runtime behavior by implementing various Life-Cycle hooks.\n   *\n   * **Metadata Properties:**\n   *\n   * * **exportAs** - name under which the component instance is exported in a template. Can be\n   * given a single name or a comma-delimited list of names.\n   * * **host** - map of class property to host element bindings for events, properties and\n   * attributes\n   * * **inputs** - list of class property names to data-bind as component inputs\n   * * **outputs** - list of class property names that expose output events that others can\n   * subscribe to\n   * * **providers** - list of providers available to this component and its children\n   * * **queries** -  configure queries that can be injected into the component\n   * * **selector** - css selector that identifies this component in a template\n   *\n   * @usageNotes\n   *\n   * ```\n   * import {Directive} from '@angular/core';\n   *\n   * @Directive({\n   *   selector: 'my-directive',\n   * })\n   * export class MyDirective {\n   * }\n   * ```\n   *\n   * @Annotation\n   */\n  (obj: Directive): TypeDecorator;\n\n  /**\n   * See the `Directive` decorator.\n   */\n  new (obj: Directive): Directive;\n}\n\nexport interface Directive {\n  /**\n   * The CSS selector that triggers the instantiation of a directive.\n   *\n   * Angular only allows directives to trigger on CSS selectors that do not cross element\n   * boundaries.\n   *\n   * `selector` may be declared as one of the following:\n   *\n   * - `element-name`: select by element name.\n   * - `.class`: select by class name.\n   * - `[attribute]`: select by attribute name.\n   * - `[attribute=value]`: select by attribute name and value.\n   * - `:not(sub_selector)`: select only if the element does not match the `sub_selector`.\n   * - `selector1, selector2`: select if either `selector1` or `selector2` matches.\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * Suppose we have a directive with an `input[type=text]` selector.\n   *\n   * And the following HTML:\n   *\n   * ```html\n   * <form>\n   *   <input type=\"text\">\n   *   <input type=\"radio\">\n   * <form>\n   * ```\n   *\n   * The directive would only be instantiated on the `<input type=\"text\">` element.\n   *\n   */\n  selector?: string;\n\n  /**\n   * Enumerates the set of data-bound input properties for a directive\n   *\n   * Angular automatically updates input properties during change detection.\n   *\n   * The `inputs` property defines a set of `directiveProperty` to `bindingProperty`\n   * configuration:\n   *\n   * - `directiveProperty` specifies the component property where the value is written.\n   * - `bindingProperty` specifies the DOM property where the value is read from.\n   *\n   * When `bindingProperty` is not provided, it is assumed to be equal to `directiveProperty`.\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * The following example creates a component with two data-bound properties.\n   *\n   * ```typescript\n   * @Component({\n   *   selector: 'bank-account',\n   *   inputs: ['bankName', 'id: account-id'],\n   *   template: `\n   *     Bank Name: {{bankName}}\n   *     Account Id: {{id}}\n   *   `\n   * })\n   * class BankAccount {\n   *   bankName: string;\n   *   id: string;\n   *\n   * ```\n   */\n  inputs?: string[];\n\n  /**\n   * Enumerates the set of event-bound output properties.\n   *\n   * When an output property emits an event, an event handler attached to that event\n   * the template is invoked.\n   *\n   * The `outputs` property defines a set of `directiveProperty` to `bindingProperty`\n   * configuration:\n   *\n   * - `directiveProperty` specifies the component property that emits events.\n   * - `bindingProperty` specifies the DOM property the event handler is attached to.\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * ```typescript\n   * @Directive({\n   *   selector: 'child-dir',\n   *   exportAs: 'child'\n   * })\n   * class ChildDir {\n   * }\n   *\n   * @Component({\n   *   selector: 'main',\n   *   template: `<child-dir #c=\"child\"></child-dir>`\n   * })\n   * class MainComponent {\n   * }\n   * ```\n   */\n  outputs?: string[];\n\n  /**\n   * Specify the events, actions, properties and attributes related to the host element.\n   *\n   * @usageNotes\n   * The key corresponds to the name of the event, property or attribute on the host to\n   * bind. The value is formatted differently depending upon the type of the binding.\n   *\n   * ### Host Listeners\n   *\n   * Specifies which DOM events a directive listens to via a set of `(event)` to `method`\n   * key-value pairs:\n   *\n   * - `event`: the DOM event that the directive listens to.\n   * - `statement`: the statement to execute when the event occurs.\n   * If the evaluation of the statement returns `false`, then `preventDefault`is applied on the DOM\n   * event.\n   *\n   * To listen to global events, a target must be added to the event name.\n   * The target can be `window`, `document` or `body`.\n   *\n   * When writing a directive event binding, you can also refer to the $event local variable.\n   *\n   * The following example declares a directive that attaches a click listener to the button and\n   * counts clicks.\n   *\n   * ```typescript\n   * @Directive({\n   *   selector: 'button[counting]',\n   *   host: {\n   *     '(click)': 'onClick($event.target)'\n   *   }\n   * })\n   * class CountClicks {\n   *   numberOfClicks = 0;\n   *\n   *   onClick(btn) {\n   *     console.log(\"button\", btn, \"number of clicks:\", this.numberOfClicks++);\n   *   }\n   * }\n   *\n   * @Component({\n   *   selector: 'app',\n   *   template: `<button counting>Increment</button>`\n   * })\n   * class App {}\n   * ```\n   * See [live demo](http://plnkr.co/edit/DlA5KU?p=preview)\n   *\n   * ### Host Property Bindings\n   *\n   * Specifies which DOM properties a directive updates.\n   *\n   * Angular automatically checks host property bindings during change detection.\n   * If a binding changes, it will update the host element of the directive.\n   *\n   * The following example creates a directive that sets the `valid` and `invalid` classes\n   * on the DOM element that has ngModel directive on it.\n   *\n   * ```typescript\n   * @Directive({\n   *   selector: '[ngModel]',\n   *   host: {\n   *     '[class.valid]': 'valid',\n   *     '[class.invalid]': 'invalid'\n   *   }\n   * })\n   * class NgModelStatus {\n   *   constructor(public control:NgModel) {}\n   *   get valid { return this.control.valid; }\n   *   get invalid { return this.control.invalid; }\n   * }\n   *\n   * @Component({\n   *   selector: 'app',\n   *   template: `<input [(ngModel)]=\"prop\">`\n   * })\n   * class App {\n   *   prop;\n   * }\n   * ```\n   * See [live demo](http://plnkr.co/edit/gNg0ED?p=preview).\n   *\n   * ### Attributes\n   *\n   * Specifies static attributes that should be propagated to a host element.\n   *\n   * In this example using `my-button` directive (ex.: `<div my-button></div>`) on a host element\n   * (here: `<div>` ) will ensure that this element will get the \"button\" role.\n   *\n   * ```typescript\n   * @Directive({\n   *   selector: '[my-button]',\n   *   host: {\n   *     'role': 'button'\n   *   }\n   * })\n   * class MyButton {\n   * }\n   * ```\n   * Attaching the `my-button` directive to the host `<div>` element\n   * ensures that this element gets the \"button\" role.\n   *\n   * ```html\n   * <div my-button></div>\n   * ```\n   *\n   * @usageNotes\n   * ### Simple Example\n   *\n   * The following simple example shows how a class is injected,\n   * using a provider specified in the directive metadata:\n   *\n   * ```\n   * class Greeter {\n   *    greet(name:string) {\n   *      return 'Hello ' + name + '!';\n   *    }\n   * }\n   *\n   * @Directive({\n   *   selector: 'greet',\n   *   providers: [\n   *     Greeter\n   *   ]\n   * })\n   * class HelloWorld {\n   *   greeter:Greeter;\n   *\n   *   constructor(greeter:Greeter) {\n   *     this.greeter = greeter;\n   *   }\n   * }\n   * ```\n   */\n  providers?: Provider[];\n\n  /**\n   * Defines the name that can be used in the template to assign this directive to a variable.\n   *\n   * @usageNotes\n   * ### Simple Example\n   *\n   * ```\n   * @Directive({\n   *   selector: 'child-dir',\n   *   exportAs: 'child'\n   * })\n   * class ChildDir {\n   * }\n   *\n   * @Component({\n   *   selector: 'main',\n   *   template: `<child-dir #c=\"child\"></child-dir>`\n   * })\n   * class MainComponent {\n   * }\n   *\n   * ```\n   */\n  exportAs?: string;\n\n  /**\n   * Configures the queries that will be injected into the directive.\n   *\n   * Content queries are set before the `ngAfterContentInit` callback is called.\n   * View queries are set before the `ngAfterViewInit` callback is called.\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * The followoing example (shows what??)\n   * ```\n   * @Component({\n   *   selector: 'someDir',\n   *   queries: {\n   *     contentChildren: new ContentChildren(ChildDirective),\n   *     viewChildren: new ViewChildren(ChildDirective)\n   *   },\n   *   template: '<child-directive></child-directive>'\n   * })\n   * class SomeDir {\n   *   contentChildren: QueryList<ChildDirective>,\n   *   viewChildren: QueryList<ChildDirective>\n   *\n   *   ngAfterContentInit() {\n   *     // contentChildren is set\n   *   }\n   *\n   *   ngAfterViewInit() {\n   *     // viewChildren is set\n   *   }\n   * }\n   * ```\n   *\n   * @Annotation\n   */\n  queries?: {[key: string]: any};\n}\n\n/**\n * Directive decorator and metadata.\n *\n * @Annotation\n */\nexport interface Directive {\n  /**\n   * The CSS selector that identifies this directive in a template\n   * and triggers instantiation of the directive.\n   *\n   * Declare as one of the following:\n   *\n   * - `element-name`: Select by element name.\n   * - `.class`: Select by class name.\n   * - `[attribute]`: Select by attribute name.\n   * - `[attribute=value]`: Select by attribute name and value.\n   * - `:not(sub_selector)`: Select only if the element does not match the `sub_selector`.\n   * - `selector1, selector2`: Select if either `selector1` or `selector2` matches.\n   *\n   * Angular only allows directives to apply on CSS selectors that do not cross\n   * element boundaries.\n   *\n   * For the following template HTML, a directive with an `input[type=text]` selector,\n   * would be instantiated only on the `<input type=\"text\">` element.\n   *\n   * ```html\n   * <form>\n   *   <input type=\"text\">\n   *   <input type=\"radio\">\n   * <form>\n   * ```\n   *\n   */\n  selector?: string;\n\n  /**\n   * The set of event-bound output properties.\n   * When an output property emits an event, an event handler attached\n   * to that event in the template is invoked.\n   *\n   * Each output property maps a `directiveProperty` to a `bindingProperty`:\n   * - `directiveProperty` specifies the component property that emits events.\n   * - `bindingProperty` specifies the HTML attribute the event handler is attached to.\n   *\n   */\n  outputs?: string[];\n\n  /**\n   * Maps class properties to host element bindings for properties,\n   * attributes, and events, using a set of key-value pairs.\n   *\n   * Angular automatically checks host property bindings during change detection.\n   * If a binding changes, Angular updates the directive's host element.\n   *\n   * When the key is a property of the host element, the property value is\n   * the propagated to the specified DOM property.\n   *\n   * When the key is a static attribute in the DOM, the attribute value\n   * is propagated to the specified property in the host element.\n   *\n   * For event handling:\n   * - The key is the DOM event that the directive listens to.\n   * To listen to global events, add the target to the event name.\n   * The target can be `window`, `document` or `body`.\n   * - The value is the statement to execute when the event occurs. If the\n   * statement evalueates to `false`, then `preventDefault` is applied on the DOM\n   * event. A handler method can refer to the `$event` local variable.\n   *\n   */\n  host?: {[key: string]: string};\n\n  /**\n   * See the `Component` decorator.\n   */\n  providers?: Provider[];\n\n  /**\n   * The name or names that can be used in the template to assign this directive to a variable.\n   * For multiple names, use a comma-separated string.\n   *\n   */\n  exportAs?: string;\n\n  /**\n   * Configures the queries that will be injected into the directive.\n   *\n   * Content queries are set before the `ngAfterContentInit` callback is called.\n   * View queries are set before the `ngAfterViewInit` callback is called.\n   *\n   */\n  queries?: {[key: string]: any};\n}\n\n/**\n * Type of the Component metadata.\n */\nexport const Directive: DirectiveDecorator =\n    makeDecorator('Directive', (dir: Directive = {}) => dir);\n/**\n * Component decorator interface\n *\n */\nexport interface ComponentDecorator {\n  /**\n   * Decorator that marks a class as an Angular component and provides configuration\n   * metadata that determines how the component should be processed,\n   * instantiated, and used at runtime.\n   *\n   * Components are the most basic UI building block of an Angular app.\n   * An Angular app contains a tree of Angular components.\n   *\n   * Angular components are a subset of directives, always associated with a template.\n   * Unlike other directives, only one component can be instantiated per an element in a template.\n   *\n   * A component must belong to an NgModule in order for it to be available\n   * to another component or application. To make it a member of an NgModule,\n   * list it in the `declarations` field of the `@NgModule` metadata.\n   *\n   * Note that, in addition to these options for configuring a directive,\n   * you can control a component's runtime behavior by implementing\n   * life-cycle hooks. For more information, see the\n   * [Lifecycle Hooks](guide/lifecycle-hooks) guide.\n   *\n   * @usageNotes\n   *\n   * ### Setting component inputs\n   *\n   * The following example creates a component with two data-bound properties,\n   * specified by the `inputs` value.\n   *\n   * <code-example path=\"core/ts/metadata/directives.ts\" region=\"component-input\">\n   * </code-example>\n   *\n   *\n   * ### Setting component outputs\n   *\n   * The following example shows two event emitters that emit on an interval. One\n   * emits an output every second, while the other emits every five seconds.\n   *\n   * {@example core/ts/metadata/directives.ts region='component-output-interval'}\n   *\n   * ### Injecting a class with a view provider\n   *\n   * The following simple example injects a class into a component\n   * using the view provider specified in component metadata:\n   *\n   * ```\n   * class Greeter {\n   *    greet(name:string) {\n   *      return 'Hello ' + name + '!';\n   *    }\n   * }\n   *\n   * @Directive({\n   *   selector: 'needs-greeter'\n   * })\n   * class NeedsGreeter {\n   *   greeter:Greeter;\n   *\n   *   constructor(greeter:Greeter) {\n   *     this.greeter = greeter;\n   *   }\n   * }\n   *\n   * @Component({\n   *   selector: 'greet',\n   *   viewProviders: [\n   *     Greeter\n   *   ],\n   *   template: `<needs-greeter></needs-greeter>`\n   * })\n   * class HelloWorld {\n   * }\n   *\n   * ```\n   *\n   *\n   * @Annotation\n   */\n  (obj: Component): TypeDecorator;\n  /**\n   * See the `@Component` decorator.\n   */\n  new (obj: Component): Component;\n}\n\n/**\n * Supplies configuration metadata for an Angular component.\n */\nexport interface Component extends Directive {\n  /**\n   * The change-detection strategy to use for this component.\n   *\n   * When a component is instantiated, Angular creates a change detector,\n   * which is responsible for propagating the component's bindings.\n   * The strategy is one of:\n   * - `ChangeDetectionStrategy#OnPush` sets the strategy to `CheckOnce` (on demand).\n   * - `ChangeDetectionStrategy#Default` sets the strategy to `CheckAlways`.\n   */\n  changeDetection?: ChangeDetectionStrategy;\n\n  /**\n   * Defines the set of injectable objects that are visible to its view DOM children.\n   * See [example](#injecting-a-class-with-a-view-provider).\n   *\n   */\n  viewProviders?: Provider[];\n\n  /**\n   * The module ID of the module that contains the component.\n   * The component must be able to resolve relative URLs for templates and styles.\n   * SystemJS exposes the `__moduleName` variable within each module.\n   * In CommonJS, this can  be set to `module.id`.\n   *\n   */\n  moduleId?: string;\n\n  /**\n   * The URL of a template file for an Angular component. If provided,\n   * do not supply an inline template using `template`.\n   *\n   */\n  templateUrl?: string;\n\n  /**\n   * An inline template for an Angular component. If provided,\n   * do not supply a template file using `templateUrl`.\n   *\n   */\n  template?: string;\n\n  /**\n   * One or more URLs for files containing CSS stylesheets to use\n   * in this component.\n   */\n  styleUrls?: string[];\n\n  /**\n   * One or more inline CSS stylesheets to use\n   * in this component.\n   */\n  styles?: string[];\n\n  /**\n   * One or more animation `trigger()` calls, containing\n   * `state()` and `transition()` definitions.\n   * See the [Animations guide](/guide/animations) and animations API documentation.\n   *\n   */\n  animations?: any[];\n\n  /**\n   * An encapsulation policy for the template and CSS styles. One of:\n   * - `ViewEncapsulation.Native`: Use shadow roots. This works\n   * only if natively available on the platform.\n   * - `ViewEncapsulation.Emulated`: Use shimmed CSS that\n   * emulates the native behavior.\n   * - `ViewEncapsulation.None`: Use global CSS without any\n   * encapsulation.\n   *\n   * If not supplied, the value is taken from `CompilerOptions`. The default compiler option is\n   * `ViewEncapsulation.Emulated`.\n   *\n   * If the policy is set to `ViewEncapsulation.Emulated` and the component has no `styles`\n   * or `styleUrls` specified, the policy is automatically switched to `ViewEncapsulation.None`.\n   */\n  encapsulation?: ViewEncapsulation;\n\n  /**\n   * Overrides the default encapsulation start and end delimiters (`{{` and `}}`)\n   */\n  interpolation?: [string, string];\n\n  /**\n   * A set of components that should be compiled along with\n   * this component. For each component listed here,\n   * Angular creates a {@link ComponentFactory} and stores it in the\n   * {@link ComponentFactoryResolver}.\n   */\n  entryComponents?: Array<Type<any>|any[]>;\n\n  /**\n   * True to preserve or false to remove potentially superfluous whitespace characters\n   * from the compiled template. Whitespace characters are those matching the `\\s`\n   * character class in JavaScript regular expressions. Default is false, unless\n   * overridden in compiler options.\n   */\n  preserveWhitespaces?: boolean;\n}\n\n/**\n * Component decorator and metadata.\n *\n * @usageNotes\n *\n * ### Using animations\n *\n * The following snippet shows an animation trigger in a component's\n * metadata. The trigger is attached to an element in the component's\n * template, using \"@_trigger_name_\", and a state expression that is evaluated\n * at run time to determine whether the animation should start.\n *\n * ```typescript\n * @Component({\n *   selector: 'animation-cmp',\n *   templateUrl: 'animation-cmp.html',\n *   animations: [\n *     trigger('myTriggerName', [\n *       state('on', style({ opacity: 1 }),\n *       state('off', style({ opacity: 0 }),\n *       transition('on => off', [\n *         animate(\"1s\")\n *       ])\n *     ])\n *   ]\n * })\n * ```\n *\n * ```html\n * <!-- animation-cmp.html -->\n * <div @myTriggerName=\"expression\">...</div>\n * ```\n *\n * ### Preserving whitespace\n *\n * Removing whitespace can greatly reduce AOT-generated code size, and speed up view creation.\n * As of Angular 6, default for `preserveWhitespaces` is false (whitespace is removed).\n * To change the default setting for all components in your application, set\n * the `preserveWhitespaces` option of the AOT compiler.\n *\n * Current implementation removes whitespace characters as follows:\n * - Trims all whitespaces at the beginning and the end of a template.\n * - Removes whitespace-only text nodes. For example,\n * `<button>Action 1</button>  <button>Action 2</button>` becomes\n * `<button>Action 1</button><button>Action 2</button>`.\n * - Replaces a series of whitespace characters in text nodes with a single space.\n * For example, `<span>\\n some text\\n</span>` becomes `<span> some text </span>`.\n * - Does NOT alter text nodes inside HTML tags such as `<pre>` or `<textarea>`,\n * where whitespace characters are significant.\n *\n * Note that these transformations can influence DOM nodes layout, although impact\n * should be minimal.\n *\n * You can override the default behavior to preserve whitespace characters\n * in certain fragments of a template. For example, you can exclude an entire\n * DOM sub-tree by using the `ngPreserveWhitespaces` attribute:\n *\n * ```html\n * <div ngPreserveWhitespaces>\n *     whitespaces are preserved here\n *     <span>    and here </span>\n * </div>\n * ```\n *\n * You can force a single space to be preserved in a text node by using `&ngsp;`,\n * which is replaced with a space character by Angular's template\n * compiler:\n *\n * ```html\n * <a>Spaces</a>&ngsp;<a>between</a>&ngsp;<a>links.</a>\n * <!-->compiled to be equivalent to:</>\n *  <a>Spaces</a> <a>between</a> <a>links.</a>\n * ```\n *\n * Note that sequences of `&ngsp;` are still collapsed to just one space character when\n * the `preserveWhitespaces` option is set to `false`.\n *\n * ```html\n * <a>before</a>&ngsp;&ngsp;&ngsp;<a>after</a>\n * <!-->compiled to be equivalent to:</>\n *  <a>Spaces</a> <a>between</a> <a>links.</a>\n * ```\n *\n * To preserve sequences of whitespace characters, use the\n * `ngPreserveWhitespaces` attribute.\n *\n * @Annotation\n */\nexport const Component: ComponentDecorator = makeDecorator(\n    'Component', (c: Component = {}) => ({changeDetection: ChangeDetectionStrategy.Default, ...c}),\n    Directive);\n\n/**\n * Type of the Pipe decorator / constructor function.\n */\nexport interface PipeDecorator {\n  /**\n   * Declares a reusable pipe function, and supplies configuration metadata.\n   *\n   */\n  (obj: Pipe): TypeDecorator;\n\n  /**\n   * See the `Pipe` decorator.\n   */\n  new (obj: Pipe): Pipe;\n}\n\n/**\n * Type of the Pipe metadata.\n */\nexport interface Pipe {\n  /**\n   * The pipe name to use in template bindings.\n   *\n   */\n  name: string;\n\n  /**\n   * When true, the pipe is pure, meaning that the\n   * `transform()` method is invoked only when its input arguments\n   * change. Pipes are pure by default.\n   *\n   * If the pipe has internal state (that is, the result\n   * depends on state other than its arguments), set `pure` to false.\n   * In this case, the pipe is invoked on each change-detection cycle,\n   * even if the arguments have not changed.\n   */\n  pure?: boolean;\n}\n\n/**\n *\n *\n * @Annotation\n */\nexport const Pipe: PipeDecorator = makeDecorator('Pipe', (p: Pipe) => ({pure: true, ...p}));\n\n\n/**\n *\n */\nexport interface InputDecorator {\n  /**\n   * Decorator that marks a class as pipe and supplies configuration metadata.\n   *\n   * A pipe class must implement the `PipeTransform` interface.\n   * For example, if the name is \"myPipe\", use a template binding expression\n   * such as the following:\n   *\n   * ```\n   * {{ exp | myPipe }}\n   * ```\n   *\n   * The result of the expression is passed to the pipe's `transform()` method.\n   *\n   * A pipe must belong to an NgModule in order for it to be available\n   * to a template. To make it a member of an NgModule,\n   * list it in the `declarations` field of the `@NgModule` metadata.\n   *\n   */\n  (bindingPropertyName?: string): any;\n  new (bindingPropertyName?: string): any;\n}\n\n/**\n * Type of metadata for an `Input` property.\n *\n *\n */\nexport interface Input {\n  /**\n   * Decorator that marks a class field as an input property and supplies configuration metadata.\n   * Declares a data-bound input property, which Angular automatically updates\n   * during change detection.\n   *\n   * @usageNotes\n   *\n   * You can supply an optional name to use in templates when the\n   * component is instantiated, that maps to the\n   * name of the bound property. By default, the original\n   * name of the bound property is used for input binding.\n   *\n   * The following example creates a component with two input properties,\n   * one of which is given a special binding name.\n   *\n   * ```typescript\n   * @Component({\n   *   selector: 'bank-account',\n   *   template: `\n   *     Bank Name: {{bankName}}\n  *      Account Id: {{id}}\n   *   `\n   * })\n   * class BankAccount {\n   *   // This property is bound using its original name.\n   *   @Input() bankName: string;\n   *   // this property value is bound to a different property name\n   *   // when this component is instantiated in a template.\n   *   @Input('account-id') id: string;\n   *\n   *   // this property is not bound, and is not automatically updated by Angular\n   *   normalizedBankName: string;\n   * }\n   *\n   * @Component({\n   *   selector: 'app',\n   *   template: `\n   *     <bank-account bankName=\"RBC\" account-id=\"4747\"></bank-account>\n   *   `\n   * })\n   *\n   * class App {}\n   * ```\n   */\n  bindingPropertyName?: string;\n}\n\n/**\n *\n * @Annotation\n */\nexport const Input: InputDecorator =\n    makePropDecorator('Input', (bindingPropertyName?: string) => ({bindingPropertyName}));\n\n/**\n * Type of the Output decorator / constructor function.\n */\nexport interface OutputDecorator {\n  /**\n  * Decorator that marks a class field as an output property and supplies configuration metadata.\n  * Declares a data-bound output property, which Angular automatically updates\n  * during change detection.\n  *\n  * @usageNotes\n  *\n  * You can supply an optional name to use in templates when the\n  * component is instantiated, that maps to the\n  * name of the bound property. By default, the original\n  * name of the bound property is used for output binding.\n  *\n  * See `@Input` decorator for an example of providing a binding name.\n  *\n  */\n  (bindingPropertyName?: string): any;\n  new (bindingPropertyName?: string): any;\n}\n\n/**\n * Type of the Output metadata.\n */\nexport interface Output { bindingPropertyName?: string; }\n\n/**\n *\n * @Annotation\n */\nexport const Output: OutputDecorator =\n    makePropDecorator('Output', (bindingPropertyName?: string) => ({bindingPropertyName}));\n\n\n/**\n * Type of the HostBinding decorator / constructor function.\n */\nexport interface HostBindingDecorator {\n  /**\n   * Decorator that marks a DOM property as a host-binding property and supplies configuration\n   * metadata.\n   * Angular automatically checks host property bindings during change detection, and\n   * if a binding changes it updates the host element of the directive.\n   *\n   * @usageNotes\n   *\n   * The following example creates a directive that sets the `valid` and `invalid`\n   * properties on the DOM element that has an `ngModel` directive on it.\n   *\n   * ```typescript\n   * @Directive({selector: '[ngModel]'})\n   * class NgModelStatus {\n   *   constructor(public control: NgModel) {}\n   *   @HostBinding('class.valid') get valid() { return this.control.valid; }\n   *   @HostBinding('class.invalid') get invalid() { return this.control.invalid; }\n   * }\n   *\n   * @Component({\n   *   selector: 'app',\n   *   template: `<input [(ngModel)]=\"prop\">`,\n   * })\n   * class App {\n   *   prop;\n   * }\n   * ```\n   */\n  (hostPropertyName?: string): any;\n  new (hostPropertyName?: string): any;\n}\n\n/**\n * Type of the HostBinding metadata.\n *\n */\nexport interface HostBinding { hostPropertyName?: string; }\n\n/**\n *\n * @Annotation\n */\nexport const HostBinding: HostBindingDecorator =\n    makePropDecorator('HostBinding', (hostPropertyName?: string) => ({hostPropertyName}));\n\n\n/**\n * Type of the HostListener decorator / constructor function.\n */\nexport interface HostListenerDecorator {\n  (eventName: string, args?: string[]): any;\n  new (eventName: string, args?: string[]): any;\n}\n\n/**\n * Type of the HostListener metadata.\n */\nexport interface HostListener {\n  /**\n   * The CSS event to listen for.\n   */\n  eventName?: string;\n  /**\n   * A set of arguments to pass to the handler method when the event occurs.\n   */\n  args?: string[];\n}\n\n/**\n * Binds a CSS event to a host listener and supplies configuration metadata.\n * Angular invokes the supplied handler method when the host element emits the specified event,\n * and updates the bound element with the result.\n * If the handler method returns false, applies `preventDefault` on the bound element.\n *\n * @usageNotes\n *\n * The following example declares a directive\n * that attaches a click listener to a button and counts clicks.\n *\n * ```\n * @Directive({selector: 'button[counting]'})\n * class CountClicks {\n *   numberOfClicks = 0;\n *\n *   @HostListener('click', ['$event.target'])\n *   onClick(btn) {\n *     console.log('button', btn, 'number of clicks:', this.numberOfClicks++);\n *  }\n * }\n *\n * @Component({\n *   selector: 'app',\n *   template: '<button counting>Increment</button>',\n * })\n * class App {}\n * ```\n *\n * @Annotation\n */\nexport const HostListener: HostListenerDecorator =\n    makePropDecorator('HostListener', (eventName?: string, args?: string[]) => ({eventName, args}));\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @description\n *\n * Represents a type that a Component or other object is instances of.\n *\n * An example of a `Type` is `MyCustomComponent` class, which in JavaScript is be represented by\n * the `MyCustomComponent` constructor function.\n *\n *\n */\nexport const Type = Function;\n\nexport function isType(v: any): v is Type<any> {\n  return typeof v === 'function';\n}\n\nexport interface Type<T> extends Function { new (...args: any[]): T; }\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n// Import zero symbols from zone.js. This causes the zone ambient type to be\n// added to the type-checker, without emitting any runtime module load statement\nimport {} from 'zone.js';\n\n// TODO(jteplitz602): Load WorkerGlobalScope from lib.webworker.d.ts file #3492\ndeclare var WorkerGlobalScope: any /** TODO #9100 */;\n// CommonJS / Node have global context exposed as \"global\" variable.\n// We don't want to include the whole node.d.ts this this compilation unit so we'll just fake\n// the global \"global\" var for now.\ndeclare var global: any /** TODO #9100 */;\nconst __window = typeof window !== 'undefined' && window;\nconst __self = typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' &&\n    self instanceof WorkerGlobalScope && self;\nconst __global = typeof global !== 'undefined' && global;\nconst _global: {[name: string]: any} = __window || __global || __self;\n\nconst promise: Promise<any> = Promise.resolve(0);\n/**\n * Attention: whenever providing a new value, be sure to add an\n * entry into the corresponding `....externs.js` file,\n * so that closure won't use that global for its purposes.\n */\nexport {_global as global};\n\n// When Symbol.iterator doesn't exist, retrieves the key used in es6-shim\ndeclare const Symbol: any;\nlet _symbolIterator: any = null;\nexport function getSymbolIterator(): string|symbol {\n  if (!_symbolIterator) {\n    const Symbol = _global['Symbol'];\n    if (Symbol && Symbol.iterator) {\n      _symbolIterator = Symbol.iterator;\n    } else {\n      // es6-shim specific logic\n      const keys = Object.getOwnPropertyNames(Map.prototype);\n      for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i];\n        if (key !== 'entries' && key !== 'size' &&\n            (Map as any).prototype[key] === Map.prototype['entries']) {\n          _symbolIterator = key;\n        }\n      }\n    }\n  }\n  return _symbolIterator;\n}\n\nexport function scheduleMicroTask(fn: Function) {\n  if (typeof Zone === 'undefined') {\n    // use promise to schedule microTask instead of use Zone\n    promise.then(() => { fn && fn.apply(null, null); });\n  } else {\n    Zone.current.scheduleMicroTask('scheduleMicrotask', fn);\n  }\n}\n\n// JS has NaN !== NaN\nexport function looseIdentical(a: any, b: any): boolean {\n  return a === b || typeof a === 'number' && typeof b === 'number' && isNaN(a) && isNaN(b);\n}\n\nexport function stringify(token: any): string {\n  if (typeof token === 'string') {\n    return token;\n  }\n\n  if (token instanceof Array) {\n    return '[' + token.map(stringify).join(', ') + ']';\n  }\n\n  if (token == null) {\n    return '' + token;\n  }\n\n  if (token.overriddenName) {\n    return `${token.overriddenName}`;\n  }\n\n  if (token.name) {\n    return `${token.name}`;\n  }\n\n  const res = token.toString();\n\n  if (res == null) {\n    return '' + res;\n  }\n\n  const newLineIndex = res.indexOf('\\n');\n  return newLineIndex === -1 ? res : res.substring(0, newLineIndex);\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Type, isType} from '../type';\nimport {global, stringify} from '../util';\nimport {ANNOTATIONS, PARAMETERS, PROP_METADATA} from '../util/decorators';\n\nimport {PlatformReflectionCapabilities} from './platform_reflection_capabilities';\nimport {GetterFn, MethodFn, SetterFn} from './types';\n\n\n/**\n * Attention: These regex has to hold even if the code is minified!\n */\nexport const DELEGATE_CTOR = /^function\\s+\\S+\\(\\)\\s*{[\\s\\S]+\\.apply\\(this,\\s*arguments\\)/;\nexport const INHERITED_CLASS = /^class\\s+[A-Za-z\\d$_]*\\s*extends\\s+[A-Za-z\\d$_]+\\s*{/;\nexport const INHERITED_CLASS_WITH_CTOR =\n    /^class\\s+[A-Za-z\\d$_]*\\s*extends\\s+[A-Za-z\\d$_]+\\s*{[\\s\\S]*constructor\\s*\\(/;\n\nexport class ReflectionCapabilities implements PlatformReflectionCapabilities {\n  private _reflect: any;\n\n  constructor(reflect?: any) { this._reflect = reflect || global['Reflect']; }\n\n  isReflectionEnabled(): boolean { return true; }\n\n  factory<T>(t: Type<T>): (args: any[]) => T { return (...args: any[]) => new t(...args); }\n\n  /** @internal */\n  _zipTypesAndAnnotations(paramTypes: any[], paramAnnotations: any[]): any[][] {\n    let result: any[][];\n\n    if (typeof paramTypes === 'undefined') {\n      result = new Array(paramAnnotations.length);\n    } else {\n      result = new Array(paramTypes.length);\n    }\n\n    for (let i = 0; i < result.length; i++) {\n      // TS outputs Object for parameters without types, while Traceur omits\n      // the annotations. For now we preserve the Traceur behavior to aid\n      // migration, but this can be revisited.\n      if (typeof paramTypes === 'undefined') {\n        result[i] = [];\n      } else if (paramTypes[i] != Object) {\n        result[i] = [paramTypes[i]];\n      } else {\n        result[i] = [];\n      }\n      if (paramAnnotations && paramAnnotations[i] != null) {\n        result[i] = result[i].concat(paramAnnotations[i]);\n      }\n    }\n    return result;\n  }\n\n  private _ownParameters(type: Type<any>, parentCtor: any): any[][]|null {\n    const typeStr = type.toString();\n    // If we have no decorators, we only have function.length as metadata.\n    // In that case, to detect whether a child class declared an own constructor or not,\n    // we need to look inside of that constructor to check whether it is\n    // just calling the parent.\n    // This also helps to work around for https://github.com/Microsoft/TypeScript/issues/12439\n    // that sets 'design:paramtypes' to []\n    // if a class inherits from another class but has no ctor declared itself.\n    if (DELEGATE_CTOR.exec(typeStr) ||\n        (INHERITED_CLASS.exec(typeStr) && !INHERITED_CLASS_WITH_CTOR.exec(typeStr))) {\n      return null;\n    }\n\n    // Prefer the direct API.\n    if ((<any>type).parameters && (<any>type).parameters !== parentCtor.parameters) {\n      return (<any>type).parameters;\n    }\n\n    // API of tsickle for lowering decorators to properties on the class.\n    const tsickleCtorParams = (<any>type).ctorParameters;\n    if (tsickleCtorParams && tsickleCtorParams !== parentCtor.ctorParameters) {\n      // Newer tsickle uses a function closure\n      // Retain the non-function case for compatibility with older tsickle\n      const ctorParameters =\n          typeof tsickleCtorParams === 'function' ? tsickleCtorParams() : tsickleCtorParams;\n      const paramTypes = ctorParameters.map((ctorParam: any) => ctorParam && ctorParam.type);\n      const paramAnnotations = ctorParameters.map(\n          (ctorParam: any) =>\n              ctorParam && convertTsickleDecoratorIntoMetadata(ctorParam.decorators));\n      return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);\n    }\n\n    // API for metadata created by invoking the decorators.\n    const paramAnnotations = type.hasOwnProperty(PARAMETERS) && (type as any)[PARAMETERS];\n    const paramTypes = this._reflect && this._reflect.getOwnMetadata &&\n        this._reflect.getOwnMetadata('design:paramtypes', type);\n    if (paramTypes || paramAnnotations) {\n      return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);\n    }\n\n    // If a class has no decorators, at least create metadata\n    // based on function.length.\n    // Note: We know that this is a real constructor as we checked\n    // the content of the constructor above.\n    return new Array((<any>type.length)).fill(undefined);\n  }\n\n  parameters(type: Type<any>): any[][] {\n    // Note: only report metadata if we have at least one class decorator\n    // to stay in sync with the static reflector.\n    if (!isType(type)) {\n      return [];\n    }\n    const parentCtor = getParentCtor(type);\n    let parameters = this._ownParameters(type, parentCtor);\n    if (!parameters && parentCtor !== Object) {\n      parameters = this.parameters(parentCtor);\n    }\n    return parameters || [];\n  }\n\n  private _ownAnnotations(typeOrFunc: Type<any>, parentCtor: any): any[]|null {\n    // Prefer the direct API.\n    if ((<any>typeOrFunc).annotations && (<any>typeOrFunc).annotations !== parentCtor.annotations) {\n      let annotations = (<any>typeOrFunc).annotations;\n      if (typeof annotations === 'function' && annotations.annotations) {\n        annotations = annotations.annotations;\n      }\n      return annotations;\n    }\n\n    // API of tsickle for lowering decorators to properties on the class.\n    if ((<any>typeOrFunc).decorators && (<any>typeOrFunc).decorators !== parentCtor.decorators) {\n      return convertTsickleDecoratorIntoMetadata((<any>typeOrFunc).decorators);\n    }\n\n    // API for metadata created by invoking the decorators.\n    if (typeOrFunc.hasOwnProperty(ANNOTATIONS)) {\n      return (typeOrFunc as any)[ANNOTATIONS];\n    }\n    return null;\n  }\n\n  annotations(typeOrFunc: Type<any>): any[] {\n    if (!isType(typeOrFunc)) {\n      return [];\n    }\n    const parentCtor = getParentCtor(typeOrFunc);\n    const ownAnnotations = this._ownAnnotations(typeOrFunc, parentCtor) || [];\n    const parentAnnotations = parentCtor !== Object ? this.annotations(parentCtor) : [];\n    return parentAnnotations.concat(ownAnnotations);\n  }\n\n  private _ownPropMetadata(typeOrFunc: any, parentCtor: any): {[key: string]: any[]}|null {\n    // Prefer the direct API.\n    if ((<any>typeOrFunc).propMetadata &&\n        (<any>typeOrFunc).propMetadata !== parentCtor.propMetadata) {\n      let propMetadata = (<any>typeOrFunc).propMetadata;\n      if (typeof propMetadata === 'function' && propMetadata.propMetadata) {\n        propMetadata = propMetadata.propMetadata;\n      }\n      return propMetadata;\n    }\n\n    // API of tsickle for lowering decorators to properties on the class.\n    if ((<any>typeOrFunc).propDecorators &&\n        (<any>typeOrFunc).propDecorators !== parentCtor.propDecorators) {\n      const propDecorators = (<any>typeOrFunc).propDecorators;\n      const propMetadata = <{[key: string]: any[]}>{};\n      Object.keys(propDecorators).forEach(prop => {\n        propMetadata[prop] = convertTsickleDecoratorIntoMetadata(propDecorators[prop]);\n      });\n      return propMetadata;\n    }\n\n    // API for metadata created by invoking the decorators.\n    if (typeOrFunc.hasOwnProperty(PROP_METADATA)) {\n      return (typeOrFunc as any)[PROP_METADATA];\n    }\n    return null;\n  }\n\n  propMetadata(typeOrFunc: any): {[key: string]: any[]} {\n    if (!isType(typeOrFunc)) {\n      return {};\n    }\n    const parentCtor = getParentCtor(typeOrFunc);\n    const propMetadata: {[key: string]: any[]} = {};\n    if (parentCtor !== Object) {\n      const parentPropMetadata = this.propMetadata(parentCtor);\n      Object.keys(parentPropMetadata).forEach((propName) => {\n        propMetadata[propName] = parentPropMetadata[propName];\n      });\n    }\n    const ownPropMetadata = this._ownPropMetadata(typeOrFunc, parentCtor);\n    if (ownPropMetadata) {\n      Object.keys(ownPropMetadata).forEach((propName) => {\n        const decorators: any[] = [];\n        if (propMetadata.hasOwnProperty(propName)) {\n          decorators.push(...propMetadata[propName]);\n        }\n        decorators.push(...ownPropMetadata[propName]);\n        propMetadata[propName] = decorators;\n      });\n    }\n    return propMetadata;\n  }\n\n  hasLifecycleHook(type: any, lcProperty: string): boolean {\n    return type instanceof Type && lcProperty in type.prototype;\n  }\n\n  guards(type: any): {[key: string]: any} { return {}; }\n\n  getter(name: string): GetterFn { return <GetterFn>new Function('o', 'return o.' + name + ';'); }\n\n  setter(name: string): SetterFn {\n    return <SetterFn>new Function('o', 'v', 'return o.' + name + ' = v;');\n  }\n\n  method(name: string): MethodFn {\n    const functionBody = `if (!o.${name}) throw new Error('\"${name}\" is undefined');\n        return o.${name}.apply(o, args);`;\n    return <MethodFn>new Function('o', 'args', functionBody);\n  }\n\n  // There is not a concept of import uri in Js, but this is useful in developing Dart applications.\n  importUri(type: any): string {\n    // StaticSymbol\n    if (typeof type === 'object' && type['filePath']) {\n      return type['filePath'];\n    }\n    // Runtime type\n    return `./${stringify(type)}`;\n  }\n\n  resourceUri(type: any): string { return `./${stringify(type)}`; }\n\n  resolveIdentifier(name: string, moduleUrl: string, members: string[], runtime: any): any {\n    return runtime;\n  }\n  resolveEnum(enumIdentifier: any, name: string): any { return enumIdentifier[name]; }\n}\n\nfunction convertTsickleDecoratorIntoMetadata(decoratorInvocations: any[]): any[] {\n  if (!decoratorInvocations) {\n    return [];\n  }\n  return decoratorInvocations.map(decoratorInvocation => {\n    const decoratorType = decoratorInvocation.type;\n    const annotationCls = decoratorType.annotationCls;\n    const annotationArgs = decoratorInvocation.args ? decoratorInvocation.args : [];\n    return new annotationCls(...annotationArgs);\n  });\n}\n\nfunction getParentCtor(ctor: Function): Type<any> {\n  const parentProto = ctor.prototype ? Object.getPrototypeOf(ctor.prototype) : null;\n  const parentCtor = parentProto ? parentProto.constructor : null;\n  // Note: We always use `Object` as the null value\n  // to simplify checking later on.\n  return parentCtor || Object;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport function getClosureSafeProperty<T>(objWithPropertyToExtract: T, target: any): string {\n  for (let key in objWithPropertyToExtract) {\n    if (objWithPropertyToExtract[key] === target) {\n      return key;\n    }\n  }\n  throw Error('Could not find renamed property on target object.');\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Type} from '../type';\nimport {stringify} from '../util';\n\n\n\n/**\n * An interface that a function passed into {@link forwardRef} has to implement.\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='forward_ref_fn'}\n * @experimental\n */\nexport interface ForwardRefFn { (): any; }\n\n/**\n * Allows to refer to references which are not yet defined.\n *\n * For instance, `forwardRef` is used when the `token` which we need to refer to for the purposes of\n * DI is declared, but not yet defined. It is also used when the `token` which we use when creating\n * a query is not yet defined.\n *\n * @usageNotes\n * ### Example\n * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='forward_ref'}\n * @experimental\n */\nexport function forwardRef(forwardRefFn: ForwardRefFn): Type<any> {\n  (<any>forwardRefFn).__forward_ref__ = forwardRef;\n  (<any>forwardRefFn).toString = function() { return stringify(this()); };\n  return (<Type<any>><any>forwardRefFn);\n}\n\n/**\n * Lazily retrieves the reference value from a forwardRef.\n *\n * Acts as the identity function when given a non-forward-ref value.\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='resolve_forward_ref'}\n *\n * @see `forwardRef`\n * @experimental\n */\nexport function resolveForwardRef(type: any): any {\n  if (typeof type === 'function' && type.hasOwnProperty('__forward_ref__') &&\n      type.__forward_ref__ === forwardRef) {\n    return (<ForwardRefFn>type)();\n  } else {\n    return type;\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ClassSansProvider, ConstructorProvider, ConstructorSansProvider, ExistingProvider, ExistingSansProvider, FactoryProvider, FactorySansProvider, StaticClassProvider, StaticClassSansProvider, ValueProvider, ValueSansProvider} from '../di/provider';\nimport {ReflectionCapabilities} from '../reflection/reflection_capabilities';\nimport {Type} from '../type';\nimport {makeDecorator, makeParamDecorator} from '../util/decorators';\nimport {EMPTY_ARRAY} from '../view/util';\n\n\n/**\n * Type of the Inject decorator / constructor function.\n */\nexport interface InjectDecorator {\n  /**\n   * A parameter decorator that specifies a dependency.\n   *\n   * For more details, see the [\"Dependency Injection Guide\"](guide/dependency-injection).\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * {@example core/di/ts/metadata_spec.ts region='Inject'}\n   *\n   * When `@Inject()` is not present, `Injector` will use the type annotation of the\n   * parameter.\n   *\n   * ### Example\n   *\n   * {@example core/di/ts/metadata_spec.ts region='InjectWithoutDecorator'}\n   */\n  (token: any): any;\n  new (token: any): Inject;\n}\n\n/**\n * Type of the Inject metadata.\n */\nexport interface Inject { token: any; }\n\n/**\n * Inject decorator and metadata.\n *\n * @Annotation\n */\nexport const Inject: InjectDecorator = makeParamDecorator('Inject', (token: any) => ({token}));\n\n\n/**\n * Type of the Optional decorator / constructor function.\n */\nexport interface OptionalDecorator {\n  /**\n   * A parameter metadata that marks a dependency as optional.\n   * `Injector` provides `null` if the dependency is not found.\n   *\n   * For more details, see the [\"Dependency Injection Guide\"](guide/dependency-injection).\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * {@example core/di/ts/metadata_spec.ts region='Optional'}\n   */\n  (): any;\n  new (): Optional;\n}\n\n/**\n * Type of the Optional metadata.\n */\nexport interface Optional {}\n\n/**\n * Optional decorator and metadata.\n *\n * @Annotation\n */\nexport const Optional: OptionalDecorator = makeParamDecorator('Optional');\n\n/**\n * Type of the Self decorator / constructor function.\n */\nexport interface SelfDecorator {\n  /**\n   * Specifies that an `Injector` should retrieve a dependency only from itself.\n   *\n   * For more details, see the [\"Dependency Injection Guide\"](guide/dependency-injection).\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * {@example core/di/ts/metadata_spec.ts region='Self'}\n   */\n  (): any;\n  new (): Self;\n}\n\n/**\n * Type of the Self metadata.\n */\nexport interface Self {}\n\n/**\n * Self decorator and metadata.\n *\n * @Annotation\n */\nexport const Self: SelfDecorator = makeParamDecorator('Self');\n\n\n/**\n * Type of the SkipSelf decorator / constructor function.\n */\nexport interface SkipSelfDecorator {\n  /**\n   * Specifies that the dependency resolution should start from the parent injector.\n   *\n   * For more details, see the [\"Dependency Injection Guide\"](guide/dependency-injection).\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * {@example core/di/ts/metadata_spec.ts region='SkipSelf'}\n   */\n  (): any;\n  new (): SkipSelf;\n}\n\n/**\n * Type of the SkipSelf metadata.\n *\n *\n */\nexport interface SkipSelf {}\n\n/**\n * SkipSelf decorator and metadata.\n *\n * @Annotation\n */\nexport const SkipSelf: SkipSelfDecorator = makeParamDecorator('SkipSelf');\n\n/**\n * Type of the Host decorator / constructor function.\n */\nexport interface HostDecorator {\n  /**\n   * Specifies that an injector should retrieve a dependency from any injector until\n   * reaching the host element of the current component.\n   *\n   * For more details, see the [\"Dependency Injection Guide\"](guide/dependency-injection).\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * {@example core/di/ts/metadata_spec.ts region='Host'}\n   */\n  (): any;\n  new (): Host;\n}\n\n/**\n * Type of the Host metadata.\n */\nexport interface Host {}\n\n/**\n * Host decorator and metadata.\n *\n * @Annotation\n */\nexport const Host: HostDecorator = makeParamDecorator('Host');\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Type} from '../type';\nimport {stringify} from '../util';\n\nimport {InjectableDef, defineInjectable} from './defs';\nimport {resolveForwardRef} from './forward_ref';\nimport {InjectionToken} from './injection_token';\nimport {Inject, Optional, Self, SkipSelf} from './metadata';\nimport {ConstructorProvider, ExistingProvider, FactoryProvider, StaticClassProvider, StaticProvider, ValueProvider} from './provider';\n\nexport const SOURCE = '__source';\nconst _THROW_IF_NOT_FOUND = new Object();\nexport const THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;\n\n/**\n * An InjectionToken that gets the current `Injector` for `createInjector()`-style injectors.\n *\n * Requesting this token instead of `Injector` allows `StaticInjector` to be tree-shaken from a\n * project.\n *\n * @experimental\n */\nexport const INJECTOR = new InjectionToken<Injector>('INJECTOR');\n\nexport class NullInjector implements Injector {\n  get(token: any, notFoundValue: any = _THROW_IF_NOT_FOUND): any {\n    if (notFoundValue === _THROW_IF_NOT_FOUND) {\n      throw new Error(`NullInjectorError: No provider for ${stringify(token)}!`);\n    }\n    return notFoundValue;\n  }\n}\n\n/**\n * Concrete injectors implement this interface.\n *\n * For more details, see the [\"Dependency Injection Guide\"](guide/dependency-injection).\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/di/ts/injector_spec.ts region='Injector'}\n *\n * `Injector` returns itself when given `Injector` as a token:\n *\n * {@example core/di/ts/injector_spec.ts region='injectInjector'}\n *\n *\n */\nexport abstract class Injector {\n  static THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;\n  static NULL: Injector = new NullInjector();\n\n  /**\n   * Retrieves an instance from the injector based on the provided token.\n   * @returns The instance from the injector if defined, otherwise the `notFoundValue`.\n   * @throws When the `notFoundValue` is `undefined` or `Injector.THROW_IF_NOT_FOUND`.\n   */\n  abstract get<T>(token: Type<T>|InjectionToken<T>, notFoundValue?: T, flags?: InjectFlags): T;\n  /**\n   * @deprecated from v4.0.0 use Type<T> or InjectionToken<T>\n   * @suppress {duplicate}\n   */\n  abstract get(token: any, notFoundValue?: any): any;\n\n  /**\n   * @deprecated from v5 use the new signature Injector.create(options)\n   */\n  static create(providers: StaticProvider[], parent?: Injector): Injector;\n\n  static create(options: {providers: StaticProvider[], parent?: Injector, name?: string}): Injector;\n\n  /**\n   * Create a new Injector which is configure using `StaticProvider`s.\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * {@example core/di/ts/provider_spec.ts region='ConstructorProvider'}\n   */\n  static create(\n      options: StaticProvider[]|{providers: StaticProvider[], parent?: Injector, name?: string},\n      parent?: Injector): Injector {\n    if (Array.isArray(options)) {\n      return new StaticInjector(options, parent);\n    } else {\n      return new StaticInjector(options.providers, options.parent, options.name || null);\n    }\n  }\n\n  static ngInjectableDef = defineInjectable({\n    providedIn: 'any' as any,\n    factory: () => inject(INJECTOR),\n  });\n}\n\n\n\nconst IDENT = function<T>(value: T): T {\n  return value;\n};\nconst EMPTY = <any[]>[];\nconst CIRCULAR = IDENT;\nconst MULTI_PROVIDER_FN = function(): any[] {\n  return Array.prototype.slice.call(arguments);\n};\nconst GET_PROPERTY_NAME = {} as any;\nexport const USE_VALUE =\n    getClosureSafeProperty<ValueProvider>({provide: String, useValue: GET_PROPERTY_NAME});\nconst NG_TOKEN_PATH = 'ngTokenPath';\nconst NG_TEMP_TOKEN_PATH = 'ngTempTokenPath';\nconst enum OptionFlags {\n  Optional = 1 << 0,\n  CheckSelf = 1 << 1,\n  CheckParent = 1 << 2,\n  Default = CheckSelf | CheckParent\n}\nconst NULL_INJECTOR = Injector.NULL;\nconst NEW_LINE = /\\n/gm;\nconst NO_NEW_LINE = '';\n\nexport class StaticInjector implements Injector {\n  readonly parent: Injector;\n  readonly source: string|null;\n\n  private _records: Map<any, Record>;\n\n  constructor(\n      providers: StaticProvider[], parent: Injector = NULL_INJECTOR, source: string|null = null) {\n    this.parent = parent;\n    this.source = source;\n    const records = this._records = new Map<any, Record>();\n    records.set(\n        Injector, <Record>{token: Injector, fn: IDENT, deps: EMPTY, value: this, useNew: false});\n    records.set(\n        INJECTOR, <Record>{token: INJECTOR, fn: IDENT, deps: EMPTY, value: this, useNew: false});\n    recursivelyProcessProviders(records, providers);\n  }\n\n  get<T>(token: Type<T>|InjectionToken<T>, notFoundValue?: T, flags?: InjectFlags): T;\n  get(token: any, notFoundValue?: any): any;\n  get(token: any, notFoundValue?: any, flags: InjectFlags = InjectFlags.Default): any {\n    const record = this._records.get(token);\n    try {\n      return tryResolveToken(token, record, this._records, this.parent, notFoundValue, flags);\n    } catch (e) {\n      const tokenPath: any[] = e[NG_TEMP_TOKEN_PATH];\n      if (token[SOURCE]) {\n        tokenPath.unshift(token[SOURCE]);\n      }\n      e.message = formatError('\\n' + e.message, tokenPath, this.source);\n      e[NG_TOKEN_PATH] = tokenPath;\n      e[NG_TEMP_TOKEN_PATH] = null;\n      throw e;\n    }\n  }\n\n  toString() {\n    const tokens = <string[]>[], records = this._records;\n    records.forEach((v, token) => tokens.push(stringify(token)));\n    return `StaticInjector[${tokens.join(', ')}]`;\n  }\n}\n\ntype SupportedProvider =\n    ValueProvider | ExistingProvider | StaticClassProvider | ConstructorProvider | FactoryProvider;\n\ninterface Record {\n  fn: Function;\n  useNew: boolean;\n  deps: DependencyRecord[];\n  value: any;\n}\n\ninterface DependencyRecord {\n  token: any;\n  options: number;\n}\n\ntype TokenPath = Array<any>;\n\nfunction resolveProvider(provider: SupportedProvider): Record {\n  const deps = computeDeps(provider);\n  let fn: Function = IDENT;\n  let value: any = EMPTY;\n  let useNew: boolean = false;\n  let provide = resolveForwardRef(provider.provide);\n  if (USE_VALUE in provider) {\n    // We need to use USE_VALUE in provider since provider.useValue could be defined as undefined.\n    value = (provider as ValueProvider).useValue;\n  } else if ((provider as FactoryProvider).useFactory) {\n    fn = (provider as FactoryProvider).useFactory;\n  } else if ((provider as ExistingProvider).useExisting) {\n    // Just use IDENT\n  } else if ((provider as StaticClassProvider).useClass) {\n    useNew = true;\n    fn = resolveForwardRef((provider as StaticClassProvider).useClass);\n  } else if (typeof provide == 'function') {\n    useNew = true;\n    fn = provide;\n  } else {\n    throw staticError(\n        'StaticProvider does not have [useValue|useFactory|useExisting|useClass] or [provide] is not newable',\n        provider);\n  }\n  return {deps, fn, useNew, value};\n}\n\nfunction multiProviderMixError(token: any) {\n  return staticError('Cannot mix multi providers and regular providers', token);\n}\n\nfunction recursivelyProcessProviders(records: Map<any, Record>, provider: StaticProvider) {\n  if (provider) {\n    provider = resolveForwardRef(provider);\n    if (provider instanceof Array) {\n      // if we have an array recurse into the array\n      for (let i = 0; i < provider.length; i++) {\n        recursivelyProcessProviders(records, provider[i]);\n      }\n    } else if (typeof provider === 'function') {\n      // Functions were supported in ReflectiveInjector, but are not here. For safety give useful\n      // error messages\n      throw staticError('Function/Class not supported', provider);\n    } else if (provider && typeof provider === 'object' && provider.provide) {\n      // At this point we have what looks like a provider: {provide: ?, ....}\n      let token = resolveForwardRef(provider.provide);\n      const resolvedProvider = resolveProvider(provider);\n      if (provider.multi === true) {\n        // This is a multi provider.\n        let multiProvider: Record|undefined = records.get(token);\n        if (multiProvider) {\n          if (multiProvider.fn !== MULTI_PROVIDER_FN) {\n            throw multiProviderMixError(token);\n          }\n        } else {\n          // Create a placeholder factory which will look up the constituents of the multi provider.\n          records.set(token, multiProvider = <Record>{\n            token: provider.provide,\n            deps: [],\n            useNew: false,\n            fn: MULTI_PROVIDER_FN,\n            value: EMPTY\n          });\n        }\n        // Treat the provider as the token.\n        token = provider;\n        multiProvider.deps.push({token, options: OptionFlags.Default});\n      }\n      const record = records.get(token);\n      if (record && record.fn == MULTI_PROVIDER_FN) {\n        throw multiProviderMixError(token);\n      }\n      records.set(token, resolvedProvider);\n    } else {\n      throw staticError('Unexpected provider', provider);\n    }\n  }\n}\n\nfunction tryResolveToken(\n    token: any, record: Record | undefined, records: Map<any, Record>, parent: Injector,\n    notFoundValue: any, flags: InjectFlags): any {\n  try {\n    return resolveToken(token, record, records, parent, notFoundValue, flags);\n  } catch (e) {\n    // ensure that 'e' is of type Error.\n    if (!(e instanceof Error)) {\n      e = new Error(e);\n    }\n    const path: any[] = e[NG_TEMP_TOKEN_PATH] = e[NG_TEMP_TOKEN_PATH] || [];\n    path.unshift(token);\n    if (record && record.value == CIRCULAR) {\n      // Reset the Circular flag.\n      record.value = EMPTY;\n    }\n    throw e;\n  }\n}\n\nfunction resolveToken(\n    token: any, record: Record | undefined, records: Map<any, Record>, parent: Injector,\n    notFoundValue: any, flags: InjectFlags): any {\n  let value;\n  if (record && !(flags & InjectFlags.SkipSelf)) {\n    // If we don't have a record, this implies that we don't own the provider hence don't know how\n    // to resolve it.\n    value = record.value;\n    if (value == CIRCULAR) {\n      throw Error(NO_NEW_LINE + 'Circular dependency');\n    } else if (value === EMPTY) {\n      record.value = CIRCULAR;\n      let obj = undefined;\n      let useNew = record.useNew;\n      let fn = record.fn;\n      let depRecords = record.deps;\n      let deps = EMPTY;\n      if (depRecords.length) {\n        deps = [];\n        for (let i = 0; i < depRecords.length; i++) {\n          const depRecord: DependencyRecord = depRecords[i];\n          const options = depRecord.options;\n          const childRecord =\n              options & OptionFlags.CheckSelf ? records.get(depRecord.token) : undefined;\n          deps.push(tryResolveToken(\n              // Current Token to resolve\n              depRecord.token,\n              // A record which describes how to resolve the token.\n              // If undefined, this means we don't have such a record\n              childRecord,\n              // Other records we know about.\n              records,\n              // If we don't know how to resolve dependency and we should not check parent for it,\n              // than pass in Null injector.\n              !childRecord && !(options & OptionFlags.CheckParent) ? NULL_INJECTOR : parent,\n              options & OptionFlags.Optional ? null : Injector.THROW_IF_NOT_FOUND,\n              InjectFlags.Default));\n        }\n      }\n      record.value = value = useNew ? new (fn as any)(...deps) : fn.apply(obj, deps);\n    }\n  } else if (!(flags & InjectFlags.Self)) {\n    value = parent.get(token, notFoundValue, InjectFlags.Default);\n  }\n  return value;\n}\n\n\nfunction computeDeps(provider: StaticProvider): DependencyRecord[] {\n  let deps: DependencyRecord[] = EMPTY;\n  const providerDeps: any[] =\n      (provider as ExistingProvider & StaticClassProvider & ConstructorProvider).deps;\n  if (providerDeps && providerDeps.length) {\n    deps = [];\n    for (let i = 0; i < providerDeps.length; i++) {\n      let options = OptionFlags.Default;\n      let token = resolveForwardRef(providerDeps[i]);\n      if (token instanceof Array) {\n        for (let j = 0, annotations = token; j < annotations.length; j++) {\n          const annotation = annotations[j];\n          if (annotation instanceof Optional || annotation == Optional) {\n            options = options | OptionFlags.Optional;\n          } else if (annotation instanceof SkipSelf || annotation == SkipSelf) {\n            options = options & ~OptionFlags.CheckSelf;\n          } else if (annotation instanceof Self || annotation == Self) {\n            options = options & ~OptionFlags.CheckParent;\n          } else if (annotation instanceof Inject) {\n            token = (annotation as Inject).token;\n          } else {\n            token = resolveForwardRef(annotation);\n          }\n        }\n      }\n      deps.push({token, options});\n    }\n  } else if ((provider as ExistingProvider).useExisting) {\n    const token = resolveForwardRef((provider as ExistingProvider).useExisting);\n    deps = [{token, options: OptionFlags.Default}];\n  } else if (!providerDeps && !(USE_VALUE in provider)) {\n    // useValue & useExisting are the only ones which are exempt from deps all others need it.\n    throw staticError('\\'deps\\' required', provider);\n  }\n  return deps;\n}\n\nfunction formatError(text: string, obj: any, source: string | null = null): string {\n  text = text && text.charAt(0) === '\\n' && text.charAt(1) == NO_NEW_LINE ? text.substr(2) : text;\n  let context = stringify(obj);\n  if (obj instanceof Array) {\n    context = obj.map(stringify).join(' -> ');\n  } else if (typeof obj === 'object') {\n    let parts = <string[]>[];\n    for (let key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        let value = obj[key];\n        parts.push(\n            key + ':' + (typeof value === 'string' ? JSON.stringify(value) : stringify(value)));\n      }\n    }\n    context = `{${parts.join(', ')}}`;\n  }\n  return `StaticInjectorError${source ? '(' + source + ')' : ''}[${context}]: ${text.replace(NEW_LINE, '\\n  ')}`;\n}\n\nfunction staticError(text: string, obj: any): Error {\n  return new Error(formatError(text, obj));\n}\n\nfunction getClosureSafeProperty<T>(objWithPropertyToExtract: T): string {\n  for (let key in objWithPropertyToExtract) {\n    if (objWithPropertyToExtract[key] === GET_PROPERTY_NAME) {\n      return key;\n    }\n  }\n  throw Error('!prop');\n}\n\n/**\n * Injection flags for DI.\n */\nexport const enum InjectFlags {\n  Default = 0,\n\n  /**\n   * Specifies that an injector should retrieve a dependency from any injector until reaching the\n   * host element of the current component. (Only used with Element Injector)\n   */\n  Host = 1 << 0,\n  /** Don't descend into ancestors of the node requesting injection. */\n  Self = 1 << 1,\n  /** Skip the node that is requesting injection. */\n  SkipSelf = 1 << 2,\n  /** Inject `defaultValue` instead if token not found. */\n  Optional = 1 << 3,\n}\n\n/**\n * Current injector value used by `inject`.\n * - `undefined`: it is an error to call `inject`\n * - `null`: `inject` can be called but there is no injector (limp-mode).\n * - Injector instance: Use the injector for resolution.\n */\nlet _currentInjector: Injector|undefined|null = undefined;\n\nexport function setCurrentInjector(injector: Injector | null | undefined): Injector|undefined|null {\n  const former = _currentInjector;\n  _currentInjector = injector;\n  return former;\n}\n\n/**\n * Injects a token from the currently active injector.\n *\n * This function must be used in the context of a factory function such as one defined for an\n * `InjectionToken`, and will throw an error if not called from such a context.\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/di/ts/injector_spec.ts region='ShakeableInjectionToken'}\n *\n * Within such a factory function `inject` is utilized to request injection of a dependency, instead\n * of providing an additional array of dependencies as was common to do with `useFactory` providers.\n * `inject` is faster and more type-safe.\n *\n * @experimental\n */\nexport function inject<T>(token: Type<T>| InjectionToken<T>): T;\nexport function inject<T>(token: Type<T>| InjectionToken<T>, flags?: InjectFlags): T|null;\nexport function inject<T>(token: Type<T>| InjectionToken<T>, flags = InjectFlags.Default): T|null {\n  if (_currentInjector === undefined) {\n    throw new Error(`inject() must be called from an injection context`);\n  } else if (_currentInjector === null) {\n    const injectableDef: InjectableDef<T> = (token as any).ngInjectableDef;\n    if (injectableDef && injectableDef.providedIn == 'root') {\n      return injectableDef.value === undefined ? injectableDef.value = injectableDef.factory() :\n                                                 injectableDef.value;\n    }\n    throw new Error(`Injector: NOT_FOUND [${stringify(token)}]`);\n  } else {\n    return _currentInjector.get(token, flags & InjectFlags.Optional ? null : undefined, flags);\n  }\n}\n\nexport function injectArgs(types: (Type<any>| InjectionToken<any>| any[])[]): any[] {\n  const args: any[] = [];\n  for (let i = 0; i < types.length; i++) {\n    const arg = types[i];\n    if (Array.isArray(arg)) {\n      if (arg.length === 0) {\n        throw new Error('Arguments array must have arguments.');\n      }\n      let type: Type<any>|undefined = undefined;\n      let flags: InjectFlags = InjectFlags.Default;\n\n      for (let j = 0; j < arg.length; j++) {\n        const meta = arg[j];\n        if (meta instanceof Optional || meta.__proto__.ngMetadataName === 'Optional') {\n          flags |= InjectFlags.Optional;\n        } else if (meta instanceof SkipSelf || meta.__proto__.ngMetadataName === 'SkipSelf') {\n          flags |= InjectFlags.SkipSelf;\n        } else if (meta instanceof Self || meta.__proto__.ngMetadataName === 'Self') {\n          flags |= InjectFlags.Self;\n        } else if (meta instanceof Inject) {\n          type = meta.token;\n        } else {\n          type = meta;\n        }\n      }\n\n      args.push(inject(type !, flags));\n    } else {\n      args.push(inject(arg));\n    }\n  }\n  return args;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ReflectionCapabilities} from '../reflection/reflection_capabilities';\nimport {Type} from '../type';\nimport {makeDecorator, makeParamDecorator} from '../util/decorators';\nimport {getClosureSafeProperty} from '../util/property';\n\nimport {InjectableDef, InjectableType, defineInjectable} from './defs';\nimport {inject, injectArgs} from './injector';\nimport {ClassSansProvider, ConstructorProvider, ConstructorSansProvider, ExistingProvider, ExistingSansProvider, FactoryProvider, FactorySansProvider, StaticClassProvider, StaticClassSansProvider, ValueProvider, ValueSansProvider} from './provider';\n\nconst GET_PROPERTY_NAME = {} as any;\nconst USE_VALUE = getClosureSafeProperty<ValueProvider>(\n    {provide: String, useValue: GET_PROPERTY_NAME}, GET_PROPERTY_NAME);\n\n/**\n * Injectable providers used in `@Injectable` decorator.\n *\n * @experimental\n */\nexport type InjectableProvider = ValueSansProvider | ExistingSansProvider |\n    StaticClassSansProvider | ConstructorSansProvider | FactorySansProvider | ClassSansProvider;\n\n/**\n * Type of the Injectable decorator / constructor function.\n */\nexport interface InjectableDecorator {\n  /**\n   * A marker metadata that marks a class as available to `Injector` for creation.\n   *\n   * For more details, see the [\"Dependency Injection Guide\"](guide/dependency-injection).\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * {@example core/di/ts/metadata_spec.ts region='Injectable'}\n   *\n   * `Injector` will throw an error when trying to instantiate a class that\n   * does not have `@Injectable` marker, as shown in the example below.\n   *\n   * {@example core/di/ts/metadata_spec.ts region='InjectableThrows'}\n   *\n   */\n  (): any;\n  (options?: {providedIn: Type<any>| 'root' | null}&InjectableProvider): any;\n  new (): Injectable;\n  new (options?: {providedIn: Type<any>| 'root' | null}&InjectableProvider): Injectable;\n}\n\n/**\n * Type of the Injectable metadata.\n *\n * @experimental\n */\nexport interface Injectable {\n  providedIn?: Type<any>|'root'|null;\n  factory: () => any;\n}\n\nconst EMPTY_ARRAY: any[] = [];\n\nexport function convertInjectableProviderToFactory(\n    type: Type<any>, provider?: InjectableProvider): () => any {\n  if (!provider) {\n    const reflectionCapabilities = new ReflectionCapabilities();\n    const deps = reflectionCapabilities.parameters(type);\n    // TODO - convert to flags.\n    return () => new type(...injectArgs(deps as any[]));\n  }\n\n  if (USE_VALUE in provider) {\n    const valueProvider = (provider as ValueSansProvider);\n    return () => valueProvider.useValue;\n  } else if ((provider as ExistingSansProvider).useExisting) {\n    const existingProvider = (provider as ExistingSansProvider);\n    return () => inject(existingProvider.useExisting);\n  } else if ((provider as FactorySansProvider).useFactory) {\n    const factoryProvider = (provider as FactorySansProvider);\n    return () => factoryProvider.useFactory(...injectArgs(factoryProvider.deps || EMPTY_ARRAY));\n  } else if ((provider as StaticClassSansProvider | ClassSansProvider).useClass) {\n    const classProvider = (provider as StaticClassSansProvider | ClassSansProvider);\n    let deps = (provider as StaticClassSansProvider).deps;\n    if (!deps) {\n      const reflectionCapabilities = new ReflectionCapabilities();\n      deps = reflectionCapabilities.parameters(type);\n    }\n    return () => new classProvider.useClass(...injectArgs(deps));\n  } else {\n    let deps = (provider as ConstructorSansProvider).deps;\n    if (!deps) {\n      const reflectionCapabilities = new ReflectionCapabilities();\n      deps = reflectionCapabilities.parameters(type);\n    }\n    return () => new type(...injectArgs(deps !));\n  }\n}\n\n/**\n* Injectable decorator and metadata.\n*\n* @Annotation\n*/\nexport const Injectable: InjectableDecorator = makeDecorator(\n    'Injectable', undefined, undefined, undefined,\n    (injectableType: InjectableType<any>,\n     options: {providedIn?: Type<any>| 'root' | null} & InjectableProvider) => {\n      if (options && options.providedIn !== undefined &&\n          injectableType.ngInjectableDef === undefined) {\n        injectableType.ngInjectableDef = defineInjectable({\n          providedIn: options.providedIn,\n          factory: convertInjectableProviderToFactory(injectableType, options)\n        });\n      }\n    });\n\n/**\n * Type representing injectable service.\n *\n * @experimental\n */\nexport interface InjectableType<T> extends Type<T> { ngInjectableDef: InjectableDef<T>; }\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {InjectorDef, InjectorType, defineInjector} from '../di/defs';\nimport {convertInjectableProviderToFactory} from '../di/injectable';\nimport {Provider} from '../di/provider';\nimport {Type} from '../type';\nimport {TypeDecorator, makeDecorator} from '../util/decorators';\n\n\n/**\n * A wrapper around an NgModule that associates it with the providers.\n *\n *\n */\nexport interface ModuleWithProviders {\n  ngModule: Type<any>;\n  providers?: Provider[];\n}\n\n/**\n * A schema definition associated with an NgModule.\n * \n * @see `@NgModule`, `CUSTOM_ELEMENTS_SCHEMA`, `NO_ERRORS_SCHEMA`\n * \n * @param name The name of a defined schema.\n *\n * @experimental\n */\nexport interface SchemaMetadata { name: string; }\n\n/**\n * Defines a schema that allows an NgModule to contain the following:\n * - Non-Angular elements named with dash case (`-`).\n * - Element properties named with dash case (`-`).\n * Dash case is the naming convention for custom elements.\n *\n *\n */\nexport const CUSTOM_ELEMENTS_SCHEMA: SchemaMetadata = {\n  name: 'custom-elements'\n};\n\n/**\n * Defines a schema that allows any property on any element.\n *\n * @experimental\n */\nexport const NO_ERRORS_SCHEMA: SchemaMetadata = {\n  name: 'no-errors-schema'\n};\n\n\n/**\n * Type of the NgModule decorator / constructor function.\n *\n *\n */\nexport interface NgModuleDecorator {\n  /**\n   * Marks a class as an NgModule and supplies configuration metadata.\n   */\n  (obj?: NgModule): TypeDecorator;\n  new (obj?: NgModule): NgModule;\n}\n\n/**\n * Type of the NgModule metadata.\n *\n *\n */\nexport interface NgModule {\n  /**\n   * The set of injectable objects that are available in the injector\n   * of this module.\n   *\n   * @usageNotes\n   *\n   * The following example defines a class that is injected in\n   * the HelloWorld NgModule:\n   *\n   * ```\n   * class Greeter {\n   *    greet(name:string) {\n   *      return 'Hello ' + name + '!';\n   *    }\n   * }\n   *\n   * @NgModule({\n   *   providers: [\n   *     Greeter\n   *   ]\n   * })\n   * class HelloWorld {\n   *   greeter:Greeter;\n   *\n   *   constructor(greeter:Greeter) {\n   *     this.greeter = greeter;\n   *   }\n   * }\n   * ```\n   */\n  providers?: Provider[];\n\n  /**\n   * The set of directives and pipes that belong to this module.\n   *\n   * @usageNotes\n   *\n   * The following example allows the CommonModule to use the `NgFor`\n   * directive.\n   *\n   * ```javascript\n   * @NgModule({\n   *   declarations: [NgFor]\n   * })\n   * class CommonModule {\n   * }\n   * ```\n   */\n  declarations?: Array<Type<any>|any[]>;\n\n  /**\n   * The set of NgModules, with or without providers,\n   * whose exported directives/pipes\n   * are available to templates in this module.\n   *\n   * @usageNotes\n   *\n   * The following example allows MainModule to use CommonModule:\n   *\n   * ```javascript\n   * @NgModule({\n   *   imports: [CommonModule]\n   * })\n   * class MainModule {\n   * }\n   * ```\n   *  @see {@link ModuleWithProviders}\n   */\n  imports?: Array<Type<any>|ModuleWithProviders|any[]>;\n\n  /**\n   * The set of directives, pipe, and NgModules that can be used\n   * within the template of any component that is part of an\n   * NgModule that imports this NgModule.\n   *\n   * @usageNotes\n   *\n   * The following example exports the `NgFor` directive from CommonModule.\n   *\n   * ```javascript\n   * @NgModule({\n   *   exports: [NgFor]\n   * })\n   * class CommonModule {\n   * }\n   * ```\n   */\n  exports?: Array<Type<any>|any[]>;\n\n  /**\n   * The set of components to compile when this NgModule is defined.\n   * For each component listed here, Angular creates a `ComponentFactory`\n   * and stores it in the `ComponentFactoryResolver`.\n   */\n  entryComponents?: Array<Type<any>|any[]>;\n\n  /**\n   * The set of components that are bootstrapped when\n   * this module is bootstrapped. The components listed here\n   * are automatically added to `entryComponents`.\n   */\n  bootstrap?: Array<Type<any>|any[]>;\n\n  /**\n   * The set of schemas that declare elements to be allowed in the NgModule.\n   * Elements and properties that are neither Angular components nor directives\n   * must be declared in a schema.\n   *\n   * Allowed value are `NO_ERRORS_SCHEMA` and `CUSTOM_ELEMENTS_SCHEMA`.\n   *\n   * @security When using one of `NO_ERRORS_SCHEMA` or `CUSTOM_ELEMENTS_SCHEMA`\n   * you must ensure that allowed elements and properties securely escape inputs.\n   */\n  schemas?: Array<SchemaMetadata|any[]>;\n\n  /**\n   * A name or path that uniquely identifies this NgModule in `getModuleFactory`.\n   * If left `undefined`, the NgModule is not registered with\n   * `getModuleFactory`.\n   */\n  id?: string;\n}\n\n/**\n * Decorator that marks the following class as an NgModule, and supplies\n * configuration metadata for it.\n *\n * @Annotation\n */\nexport const NgModule: NgModuleDecorator = makeDecorator(\n    'NgModule', (ngModule: NgModule) => ngModule, undefined, undefined,\n    /**\n     * Decorator that marks the following class as an NgModule, and supplies\n     * configuration metadata for it.\n     */\n    (moduleType: InjectorType<any>, metadata: NgModule) => {\n      let imports = (metadata && metadata.imports) || [];\n      if (metadata && metadata.exports) {\n        imports = [...imports, metadata.exports];\n      }\n\n      moduleType.ngInjectorDef = defineInjector({\n        factory: convertInjectableProviderToFactory(moduleType, {useClass: moduleType}),\n        providers: metadata && metadata.providers,\n        imports: imports,\n      });\n    });\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Defines template and style encapsulation options available for Component's {@link Component}.\n *\n * See {@link Component#encapsulation encapsulation}.\n *\n */\nexport enum ViewEncapsulation {\n  /**\n   * Emulate `Native` scoping of styles by adding an attribute containing surrogate id to the Host\n   * Element and pre-processing the style rules provided via {@link Component#styles styles} or\n   * {@link Component#styleUrls styleUrls}, and adding the new Host Element attribute to all\n   * selectors.\n   *\n   * This is the default option.\n   */\n  Emulated = 0,\n  /**\n   * @deprecated v6.1.0 - use {ViewEncapsulation.ShadowDom} instead.\n   * Use the native encapsulation mechanism of the renderer.\n   *\n   * For the DOM this means using the deprecated [Shadow DOM\n   * v0](https://w3c.github.io/webcomponents/spec/shadow/) and\n   * creating a ShadowRoot for Component's Host Element.\n   */\n  Native = 1,\n  /**\n   * Don't provide any template or style encapsulation.\n   */\n  None = 2,\n\n  /**\n   * Use Shadow DOM to encapsulate styles.\n   *\n   * For the DOM this means using modern [Shadow\n   * DOM](https://w3c.github.io/webcomponents/spec/shadow/) and\n   * creating a ShadowRoot for Component's Host Element.\n   *\n   * ### Example\n   * {@example core/ts/metadata/encapsulation.ts region='longform'}\n   */\n  ShadowDom = 3\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * This indirection is needed to free up Component, etc symbols in the public API\n * to be used by the decorator versions of these annotations.\n */\n\nimport {Attribute, ContentChild, ContentChildren, Query, ViewChild, ViewChildren} from './metadata/di';\nimport {Component, Directive, HostBinding, HostListener, Input, Output, Pipe} from './metadata/directives';\nimport {ModuleWithProviders, NgModule, SchemaMetadata} from './metadata/ng_module';\nimport {ViewEncapsulation} from './metadata/view';\n\nexport {ANALYZE_FOR_ENTRY_COMPONENTS, Attribute, ContentChild, ContentChildDecorator, ContentChildren, ContentChildrenDecorator, Query, ViewChild, ViewChildDecorator, ViewChildren, ViewChildrenDecorator} from './metadata/di';\nexport {Component, ComponentDecorator, Directive, DirectiveDecorator, HostBinding, HostListener, Input, Output, Pipe} from './metadata/directives';\nexport {AfterContentChecked, AfterContentInit, AfterViewChecked, AfterViewInit, DoCheck, OnChanges, OnDestroy, OnInit} from './metadata/lifecycle_hooks';\nexport {CUSTOM_ELEMENTS_SCHEMA, ModuleWithProviders, NO_ERRORS_SCHEMA, NgModule, SchemaMetadata} from './metadata/ng_module';\nexport {ViewEncapsulation} from './metadata/view';\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @description Represents the version of Angular\n *\n *\n */\nexport class Version {\n  public readonly major: string;\n  public readonly minor: string;\n  public readonly patch: string;\n\n  constructor(public full: string) {\n    this.major = full.split('.')[0];\n    this.minor = full.split('.')[1];\n    this.patch = full.split('.').slice(2).join('.');\n  }\n}\n\nexport const VERSION = new Version('6.0.9');\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {DebugContext} from './view';\n\nexport const ERROR_TYPE = 'ngType';\nexport const ERROR_DEBUG_CONTEXT = 'ngDebugContext';\nexport const ERROR_ORIGINAL_ERROR = 'ngOriginalError';\nexport const ERROR_LOGGER = 'ngErrorLogger';\n\n\nexport function getType(error: Error): Function {\n  return (error as any)[ERROR_TYPE];\n}\n\nexport function getDebugContext(error: Error): DebugContext {\n  return (error as any)[ERROR_DEBUG_CONTEXT];\n}\n\nexport function getOriginalError(error: Error): Error {\n  return (error as any)[ERROR_ORIGINAL_ERROR];\n}\n\nexport function getErrorLogger(error: Error): (console: Console, ...values: any[]) => void {\n  return (error as any)[ERROR_LOGGER] || defaultErrorLogger;\n}\n\n\nfunction defaultErrorLogger(console: Console, ...values: any[]) {\n  (<any>console.error)(...values);\n}","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ERROR_ORIGINAL_ERROR, getDebugContext, getErrorLogger, getOriginalError} from './errors';\n\n\n\n/**\n * Provides a hook for centralized exception handling.\n *\n * The default implementation of `ErrorHandler` prints error messages to the `console`. To\n * intercept error handling, write a custom exception handler that replaces this default as\n * appropriate for your app.\n *\n * @usageNotes\n * ### Example\n *\n * ```\n * class MyErrorHandler implements ErrorHandler {\n *   handleError(error) {\n *     // do something with the exception\n *   }\n * }\n *\n * @NgModule({\n *   providers: [{provide: ErrorHandler, useClass: MyErrorHandler}]\n * })\n * class MyModule {}\n * ```\n */\nexport class ErrorHandler {\n  /**\n   * @internal\n   */\n  _console: Console = console;\n\n  handleError(error: any): void {\n    const originalError = this._findOriginalError(error);\n    const context = this._findContext(error);\n    // Note: Browser consoles show the place from where console.error was called.\n    // We can use this to give users additional information about the error.\n    const errorLogger = getErrorLogger(error);\n\n    errorLogger(this._console, `ERROR`, error);\n    if (originalError) {\n      errorLogger(this._console, `ORIGINAL ERROR`, originalError);\n    }\n    if (context) {\n      errorLogger(this._console, 'ERROR CONTEXT', context);\n    }\n  }\n\n  /** @internal */\n  _findContext(error: any): any {\n    if (error) {\n      return getDebugContext(error) ? getDebugContext(error) :\n                                      this._findContext(getOriginalError(error));\n    }\n\n    return null;\n  }\n\n  /** @internal */\n  _findOriginalError(error: Error): any {\n    let e = getOriginalError(error);\n    while (e && getOriginalError(e)) {\n      e = getOriginalError(e);\n    }\n\n    return e;\n  }\n}\n\nexport function wrappedError(message: string, originalError: any): Error {\n  const msg =\n      `${message} caused by: ${originalError instanceof Error ? originalError.message: originalError }`;\n  const error = Error(msg);\n  (error as any)[ERROR_ORIGINAL_ERROR] = originalError;\n  return error;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {wrappedError} from '../error_handler';\nimport {ERROR_ORIGINAL_ERROR, getOriginalError} from '../errors';\nimport {Type} from '../type';\nimport {stringify} from '../util';\n\nimport {ReflectiveInjector} from './reflective_injector';\nimport {ReflectiveKey} from './reflective_key';\n\nfunction findFirstClosedCycle(keys: any[]): any[] {\n  const res: any[] = [];\n  for (let i = 0; i < keys.length; ++i) {\n    if (res.indexOf(keys[i]) > -1) {\n      res.push(keys[i]);\n      return res;\n    }\n    res.push(keys[i]);\n  }\n  return res;\n}\n\nfunction constructResolvingPath(keys: any[]): string {\n  if (keys.length > 1) {\n    const reversed = findFirstClosedCycle(keys.slice().reverse());\n    const tokenStrs = reversed.map(k => stringify(k.token));\n    return ' (' + tokenStrs.join(' -> ') + ')';\n  }\n\n  return '';\n}\n\nexport interface InjectionError extends Error {\n  keys: ReflectiveKey[];\n  injectors: ReflectiveInjector[];\n  constructResolvingMessage: (keys: ReflectiveKey[]) => string;\n  addKey(injector: ReflectiveInjector, key: ReflectiveKey): void;\n}\n\nfunction injectionError(\n    injector: ReflectiveInjector, key: ReflectiveKey,\n    constructResolvingMessage: (keys: ReflectiveKey[]) => string,\n    originalError?: Error): InjectionError {\n  const keys = [key];\n  const errMsg = constructResolvingMessage(keys);\n  const error =\n      (originalError ? wrappedError(errMsg, originalError) : Error(errMsg)) as InjectionError;\n  error.addKey = addKey;\n  error.keys = keys;\n  error.injectors = [injector];\n  error.constructResolvingMessage = constructResolvingMessage;\n  (error as any)[ERROR_ORIGINAL_ERROR] = originalError;\n  return error;\n}\n\nfunction addKey(this: InjectionError, injector: ReflectiveInjector, key: ReflectiveKey): void {\n  this.injectors.push(injector);\n  this.keys.push(key);\n  // Note: This updated message won't be reflected in the `.stack` property\n  this.message = this.constructResolvingMessage(this.keys);\n}\n\n/**\n * Thrown when trying to retrieve a dependency by key from {@link Injector}, but the\n * {@link Injector} does not have a {@link Provider} for the given key.\n *\n * @usageNotes\n * ### Example\n *\n * ```typescript\n * class A {\n *   constructor(b:B) {}\n * }\n *\n * expect(() => Injector.resolveAndCreate([A])).toThrowError();\n * ```\n */\nexport function noProviderError(injector: ReflectiveInjector, key: ReflectiveKey): InjectionError {\n  return injectionError(injector, key, function(keys: ReflectiveKey[]) {\n    const first = stringify(keys[0].token);\n    return `No provider for ${first}!${constructResolvingPath(keys)}`;\n  });\n}\n\n/**\n * Thrown when dependencies form a cycle.\n *\n * @usageNotes\n * ### Example\n *\n * ```typescript\n * var injector = Injector.resolveAndCreate([\n *   {provide: \"one\", useFactory: (two) => \"two\", deps: [[new Inject(\"two\")]]},\n *   {provide: \"two\", useFactory: (one) => \"one\", deps: [[new Inject(\"one\")]]}\n * ]);\n *\n * expect(() => injector.get(\"one\")).toThrowError();\n * ```\n *\n * Retrieving `A` or `B` throws a `CyclicDependencyError` as the graph above cannot be constructed.\n */\nexport function cyclicDependencyError(\n    injector: ReflectiveInjector, key: ReflectiveKey): InjectionError {\n  return injectionError(injector, key, function(keys: ReflectiveKey[]) {\n    return `Cannot instantiate cyclic dependency!${constructResolvingPath(keys)}`;\n  });\n}\n\n/**\n * Thrown when a constructing type returns with an Error.\n *\n * The `InstantiationError` class contains the original error plus the dependency graph which caused\n * this object to be instantiated.\n *\n * @usageNotes\n * ### Example\n *\n * ```typescript\n * class A {\n *   constructor() {\n *     throw new Error('message');\n *   }\n * }\n *\n * var injector = Injector.resolveAndCreate([A]);\n\n * try {\n *   injector.get(A);\n * } catch (e) {\n *   expect(e instanceof InstantiationError).toBe(true);\n *   expect(e.originalException.message).toEqual(\"message\");\n *   expect(e.originalStack).toBeDefined();\n * }\n * ```\n */\nexport function instantiationError(\n    injector: ReflectiveInjector, originalException: any, originalStack: any,\n    key: ReflectiveKey): InjectionError {\n  return injectionError(injector, key, function(keys: ReflectiveKey[]) {\n    const first = stringify(keys[0].token);\n    return `${originalException.message}: Error during instantiation of ${first}!${constructResolvingPath(keys)}.`;\n  }, originalException);\n}\n\n/**\n * Thrown when an object other then {@link Provider} (or `Type`) is passed to {@link Injector}\n * creation.\n *\n * @usageNotes\n * ### Example\n *\n * ```typescript\n * expect(() => Injector.resolveAndCreate([\"not a type\"])).toThrowError();\n * ```\n */\nexport function invalidProviderError(provider: any) {\n  return Error(\n      `Invalid provider - only instances of Provider and Type are allowed, got: ${provider}`);\n}\n\n/**\n * Thrown when the class has no annotation information.\n *\n * Lack of annotation information prevents the {@link Injector} from determining which dependencies\n * need to be injected into the constructor.\n *\n * @usageNotes\n * ### Example\n *\n * ```typescript\n * class A {\n *   constructor(b) {}\n * }\n *\n * expect(() => Injector.resolveAndCreate([A])).toThrowError();\n * ```\n *\n * This error is also thrown when the class not marked with {@link Injectable} has parameter types.\n *\n * ```typescript\n * class B {}\n *\n * class A {\n *   constructor(b:B) {} // no information about the parameter types of A is available at runtime.\n * }\n *\n * expect(() => Injector.resolveAndCreate([A,B])).toThrowError();\n * ```\n *\n */\nexport function noAnnotationError(typeOrFunc: Type<any>| Function, params: any[][]): Error {\n  const signature: string[] = [];\n  for (let i = 0, ii = params.length; i < ii; i++) {\n    const parameter = params[i];\n    if (!parameter || parameter.length == 0) {\n      signature.push('?');\n    } else {\n      signature.push(parameter.map(stringify).join(' '));\n    }\n  }\n  return Error(\n      'Cannot resolve all parameters for \\'' + stringify(typeOrFunc) + '\\'(' +\n      signature.join(', ') + '). ' +\n      'Make sure that all the parameters are decorated with Inject or have valid type annotations and that \\'' +\n      stringify(typeOrFunc) + '\\' is decorated with Injectable.');\n}\n\n/**\n * Thrown when getting an object by index.\n *\n * @usageNotes\n * ### Example\n *\n * ```typescript\n * class A {}\n *\n * var injector = Injector.resolveAndCreate([A]);\n *\n * expect(() => injector.getAt(100)).toThrowError();\n * ```\n *\n */\nexport function outOfBoundsError(index: number) {\n  return Error(`Index ${index} is out-of-bounds.`);\n}\n\n// TODO: add a working example after alpha38 is released\n/**\n * Thrown when a multi provider and a regular provider are bound to the same token.\n *\n * @usageNotes\n * ### Example\n *\n * ```typescript\n * expect(() => Injector.resolveAndCreate([\n *   { provide: \"Strings\", useValue: \"string1\", multi: true},\n *   { provide: \"Strings\", useValue: \"string2\", multi: false}\n * ])).toThrowError();\n * ```\n */\nexport function mixingMultiProvidersWithRegularProvidersError(\n    provider1: any, provider2: any): Error {\n  return Error(`Cannot mix multi providers and regular providers, got: ${provider1} ${provider2}`);\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {stringify} from '../util';\nimport {resolveForwardRef} from './forward_ref';\n\n\n/**\n * A unique object used for retrieving items from the {@link ReflectiveInjector}.\n *\n * Keys have:\n * - a system-wide unique `id`.\n * - a `token`.\n *\n * `Key` is used internally by {@link ReflectiveInjector} because its system-wide unique `id` allows\n * the\n * injector to store created objects in a more efficient way.\n *\n * `Key` should not be created directly. {@link ReflectiveInjector} creates keys automatically when\n * resolving\n * providers.\n * @deprecated No replacement\n */\nexport class ReflectiveKey {\n  public readonly displayName: string;\n  /**\n   * Private\n   */\n  constructor(public token: Object, public id: number) {\n    if (!token) {\n      throw new Error('Token must be defined!');\n    }\n    this.displayName = stringify(this.token);\n  }\n\n  /**\n   * Retrieves a `Key` for a token.\n   */\n  static get(token: Object): ReflectiveKey {\n    return _globalKeyRegistry.get(resolveForwardRef(token));\n  }\n\n  /**\n   * @returns the number of keys registered in the system.\n   */\n  static get numberOfKeys(): number { return _globalKeyRegistry.numberOfKeys; }\n}\n\nexport class KeyRegistry {\n  private _allKeys = new Map<Object, ReflectiveKey>();\n\n  get(token: Object): ReflectiveKey {\n    if (token instanceof ReflectiveKey) return token;\n\n    if (this._allKeys.has(token)) {\n      return this._allKeys.get(token) !;\n    }\n\n    const newKey = new ReflectiveKey(token, ReflectiveKey.numberOfKeys);\n    this._allKeys.set(token, newKey);\n    return newKey;\n  }\n\n  get numberOfKeys(): number { return this._allKeys.size; }\n}\n\nconst _globalKeyRegistry = new KeyRegistry();\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Type} from '../type';\nimport {PlatformReflectionCapabilities} from './platform_reflection_capabilities';\nimport {GetterFn, MethodFn, SetterFn} from './types';\n\nexport {PlatformReflectionCapabilities} from './platform_reflection_capabilities';\nexport {GetterFn, MethodFn, SetterFn} from './types';\n\n/**\n * Provides access to reflection data about symbols. Used internally by Angular\n * to power dependency injection and compilation.\n */\nexport class Reflector {\n  constructor(public reflectionCapabilities: PlatformReflectionCapabilities) {}\n\n  updateCapabilities(caps: PlatformReflectionCapabilities) { this.reflectionCapabilities = caps; }\n\n  factory(type: Type<any>): Function { return this.reflectionCapabilities.factory(type); }\n\n  parameters(typeOrFunc: Type<any>): any[][] {\n    return this.reflectionCapabilities.parameters(typeOrFunc);\n  }\n\n  annotations(typeOrFunc: Type<any>): any[] {\n    return this.reflectionCapabilities.annotations(typeOrFunc);\n  }\n\n  propMetadata(typeOrFunc: Type<any>): {[key: string]: any[]} {\n    return this.reflectionCapabilities.propMetadata(typeOrFunc);\n  }\n\n  hasLifecycleHook(type: any, lcProperty: string): boolean {\n    return this.reflectionCapabilities.hasLifecycleHook(type, lcProperty);\n  }\n\n  getter(name: string): GetterFn { return this.reflectionCapabilities.getter(name); }\n\n  setter(name: string): SetterFn { return this.reflectionCapabilities.setter(name); }\n\n  method(name: string): MethodFn { return this.reflectionCapabilities.method(name); }\n\n  importUri(type: any): string { return this.reflectionCapabilities.importUri(type); }\n\n  resourceUri(type: any): string { return this.reflectionCapabilities.resourceUri(type); }\n\n  resolveIdentifier(name: string, moduleUrl: string, members: string[], runtime: any): any {\n    return this.reflectionCapabilities.resolveIdentifier(name, moduleUrl, members, runtime);\n  }\n\n  resolveEnum(identifier: any, name: string): any {\n    return this.reflectionCapabilities.resolveEnum(identifier, name);\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ReflectionCapabilities} from './reflection_capabilities';\nimport {Reflector} from './reflector';\n\nexport {Reflector} from './reflector';\n\n/**\n * The {@link Reflector} used internally in Angular to access metadata\n * about symbols.\n */\nexport const reflector = new Reflector(new ReflectionCapabilities());\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {reflector} from '../reflection/reflection';\nimport {Type} from '../type';\n\nimport {resolveForwardRef} from './forward_ref';\nimport {InjectionToken} from './injection_token';\nimport {Inject, Optional, Self, SkipSelf} from './metadata';\nimport {ClassProvider, ExistingProvider, FactoryProvider, Provider, TypeProvider, ValueProvider} from './provider';\nimport {invalidProviderError, mixingMultiProvidersWithRegularProvidersError, noAnnotationError} from './reflective_errors';\nimport {ReflectiveKey} from './reflective_key';\n\n\ninterface NormalizedProvider extends TypeProvider, ValueProvider, ClassProvider, ExistingProvider,\n    FactoryProvider {}\n\n/**\n * `Dependency` is used by the framework to extend DI.\n * This is internal to Angular and should not be used directly.\n */\nexport class ReflectiveDependency {\n  constructor(\n      public key: ReflectiveKey, public optional: boolean, public visibility: Self|SkipSelf|null) {}\n\n  static fromKey(key: ReflectiveKey): ReflectiveDependency {\n    return new ReflectiveDependency(key, false, null);\n  }\n}\n\nconst _EMPTY_LIST: any[] = [];\n\n/**\n * An internal resolved representation of a `Provider` used by the `Injector`.\n *\n * @usageNotes\n * This is usually created automatically by `Injector.resolveAndCreate`.\n *\n * It can be created manually, as follows:\n *\n * ### Example\n *\n * ```typescript\n * var resolvedProviders = Injector.resolve([{ provide: 'message', useValue: 'Hello' }]);\n * var injector = Injector.fromResolvedProviders(resolvedProviders);\n *\n * expect(injector.get('message')).toEqual('Hello');\n * ```\n *\n * @experimental\n */\nexport interface ResolvedReflectiveProvider {\n  /**\n   * A key, usually a `Type<any>`.\n   */\n  key: ReflectiveKey;\n\n  /**\n   * Factory function which can return an instance of an object represented by a key.\n   */\n  resolvedFactories: ResolvedReflectiveFactory[];\n\n  /**\n   * Indicates if the provider is a multi-provider or a regular provider.\n   */\n  multiProvider: boolean;\n}\n\nexport class ResolvedReflectiveProvider_ implements ResolvedReflectiveProvider {\n  readonly resolvedFactory: ResolvedReflectiveFactory;\n\n  constructor(\n      public key: ReflectiveKey, public resolvedFactories: ResolvedReflectiveFactory[],\n      public multiProvider: boolean) {\n    this.resolvedFactory = this.resolvedFactories[0];\n  }\n}\n\n/**\n * An internal resolved representation of a factory function created by resolving `Provider`.\n * @experimental\n */\nexport class ResolvedReflectiveFactory {\n  constructor(\n      /**\n       * Factory function which can return an instance of an object represented by a key.\n       */\n      public factory: Function,\n\n      /**\n       * Arguments (dependencies) to the `factory` function.\n       */\n      public dependencies: ReflectiveDependency[]) {}\n}\n\n\n/**\n * Resolve a single provider.\n */\nfunction resolveReflectiveFactory(provider: NormalizedProvider): ResolvedReflectiveFactory {\n  let factoryFn: Function;\n  let resolvedDeps: ReflectiveDependency[];\n  if (provider.useClass) {\n    const useClass = resolveForwardRef(provider.useClass);\n    factoryFn = reflector.factory(useClass);\n    resolvedDeps = _dependenciesFor(useClass);\n  } else if (provider.useExisting) {\n    factoryFn = (aliasInstance: any) => aliasInstance;\n    resolvedDeps = [ReflectiveDependency.fromKey(ReflectiveKey.get(provider.useExisting))];\n  } else if (provider.useFactory) {\n    factoryFn = provider.useFactory;\n    resolvedDeps = constructDependencies(provider.useFactory, provider.deps);\n  } else {\n    factoryFn = () => provider.useValue;\n    resolvedDeps = _EMPTY_LIST;\n  }\n  return new ResolvedReflectiveFactory(factoryFn, resolvedDeps);\n}\n\n/**\n * Converts the `Provider` into `ResolvedProvider`.\n *\n * `Injector` internally only uses `ResolvedProvider`, `Provider` contains convenience provider\n * syntax.\n */\nfunction resolveReflectiveProvider(provider: NormalizedProvider): ResolvedReflectiveProvider {\n  return new ResolvedReflectiveProvider_(\n      ReflectiveKey.get(provider.provide), [resolveReflectiveFactory(provider)],\n      provider.multi || false);\n}\n\n/**\n * Resolve a list of Providers.\n */\nexport function resolveReflectiveProviders(providers: Provider[]): ResolvedReflectiveProvider[] {\n  const normalized = _normalizeProviders(providers, []);\n  const resolved = normalized.map(resolveReflectiveProvider);\n  const resolvedProviderMap = mergeResolvedReflectiveProviders(resolved, new Map());\n  return Array.from(resolvedProviderMap.values());\n}\n\n/**\n * Merges a list of ResolvedProviders into a list where each key is contained exactly once and\n * multi providers have been merged.\n */\nexport function mergeResolvedReflectiveProviders(\n    providers: ResolvedReflectiveProvider[],\n    normalizedProvidersMap: Map<number, ResolvedReflectiveProvider>):\n    Map<number, ResolvedReflectiveProvider> {\n  for (let i = 0; i < providers.length; i++) {\n    const provider = providers[i];\n    const existing = normalizedProvidersMap.get(provider.key.id);\n    if (existing) {\n      if (provider.multiProvider !== existing.multiProvider) {\n        throw mixingMultiProvidersWithRegularProvidersError(existing, provider);\n      }\n      if (provider.multiProvider) {\n        for (let j = 0; j < provider.resolvedFactories.length; j++) {\n          existing.resolvedFactories.push(provider.resolvedFactories[j]);\n        }\n      } else {\n        normalizedProvidersMap.set(provider.key.id, provider);\n      }\n    } else {\n      let resolvedProvider: ResolvedReflectiveProvider;\n      if (provider.multiProvider) {\n        resolvedProvider = new ResolvedReflectiveProvider_(\n            provider.key, provider.resolvedFactories.slice(), provider.multiProvider);\n      } else {\n        resolvedProvider = provider;\n      }\n      normalizedProvidersMap.set(provider.key.id, resolvedProvider);\n    }\n  }\n  return normalizedProvidersMap;\n}\n\nfunction _normalizeProviders(providers: Provider[], res: Provider[]): Provider[] {\n  providers.forEach(b => {\n    if (b instanceof Type) {\n      res.push({provide: b, useClass: b});\n\n    } else if (b && typeof b == 'object' && (b as any).provide !== undefined) {\n      res.push(b as NormalizedProvider);\n\n    } else if (b instanceof Array) {\n      _normalizeProviders(b, res);\n\n    } else {\n      throw invalidProviderError(b);\n    }\n  });\n\n  return res;\n}\n\nexport function constructDependencies(\n    typeOrFunc: any, dependencies?: any[]): ReflectiveDependency[] {\n  if (!dependencies) {\n    return _dependenciesFor(typeOrFunc);\n  } else {\n    const params: any[][] = dependencies.map(t => [t]);\n    return dependencies.map(t => _extractToken(typeOrFunc, t, params));\n  }\n}\n\nfunction _dependenciesFor(typeOrFunc: any): ReflectiveDependency[] {\n  const params = reflector.parameters(typeOrFunc);\n\n  if (!params) return [];\n  if (params.some(p => p == null)) {\n    throw noAnnotationError(typeOrFunc, params);\n  }\n  return params.map(p => _extractToken(typeOrFunc, p, params));\n}\n\nfunction _extractToken(\n    typeOrFunc: any, metadata: any[] | any, params: any[][]): ReflectiveDependency {\n  let token: any = null;\n  let optional = false;\n\n  if (!Array.isArray(metadata)) {\n    if (metadata instanceof Inject) {\n      return _createDependency(metadata.token, optional, null);\n    } else {\n      return _createDependency(metadata, optional, null);\n    }\n  }\n\n  let visibility: Self|SkipSelf|null = null;\n\n  for (let i = 0; i < metadata.length; ++i) {\n    const paramMetadata = metadata[i];\n\n    if (paramMetadata instanceof Type) {\n      token = paramMetadata;\n\n    } else if (paramMetadata instanceof Inject) {\n      token = paramMetadata.token;\n\n    } else if (paramMetadata instanceof Optional) {\n      optional = true;\n\n    } else if (paramMetadata instanceof Self || paramMetadata instanceof SkipSelf) {\n      visibility = paramMetadata;\n    } else if (paramMetadata instanceof InjectionToken) {\n      token = paramMetadata;\n    }\n  }\n\n  token = resolveForwardRef(token);\n\n  if (token != null) {\n    return _createDependency(token, optional, visibility);\n  } else {\n    throw noAnnotationError(typeOrFunc, params);\n  }\n}\n\nfunction _createDependency(\n    token: any, optional: boolean, visibility: Self | SkipSelf | null): ReflectiveDependency {\n  return new ReflectiveDependency(ReflectiveKey.get(token), optional, visibility);\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injector, THROW_IF_NOT_FOUND} from './injector';\nimport {Self, SkipSelf} from './metadata';\nimport {Provider} from './provider';\nimport {cyclicDependencyError, instantiationError, noProviderError, outOfBoundsError} from './reflective_errors';\nimport {ReflectiveKey} from './reflective_key';\nimport {ReflectiveDependency, ResolvedReflectiveFactory, ResolvedReflectiveProvider, resolveReflectiveProviders} from './reflective_provider';\n\n// Threshold for the dynamic version\nconst UNDEFINED = new Object();\n\n/**\n * A ReflectiveDependency injection container used for instantiating objects and resolving\n * dependencies.\n *\n * An `Injector` is a replacement for a `new` operator, which can automatically resolve the\n * constructor dependencies.\n *\n * In typical use, application code asks for the dependencies in the constructor and they are\n * resolved by the `Injector`.\n *\n * @usageNotes\n * ### Example\n *\n * The following example creates an `Injector` configured to create `Engine` and `Car`.\n *\n * ```typescript\n * @Injectable()\n * class Engine {\n * }\n *\n * @Injectable()\n * class Car {\n *   constructor(public engine:Engine) {}\n * }\n *\n * var injector = ReflectiveInjector.resolveAndCreate([Car, Engine]);\n * var car = injector.get(Car);\n * expect(car instanceof Car).toBe(true);\n * expect(car.engine instanceof Engine).toBe(true);\n * ```\n *\n * Notice, we don't use the `new` operator because we explicitly want to have the `Injector`\n * resolve all of the object's dependencies automatically.\n *\n * @deprecated from v5 - slow and brings in a lot of code, Use `Injector.create` instead.\n */\nexport abstract class ReflectiveInjector implements Injector {\n  /**\n   * Turns an array of provider definitions into an array of resolved providers.\n   *\n   * A resolution is a process of flattening multiple nested arrays and converting individual\n   * providers into an array of `ResolvedReflectiveProvider`s.\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * ```typescript\n   * @Injectable()\n   * class Engine {\n   * }\n   *\n   * @Injectable()\n   * class Car {\n   *   constructor(public engine:Engine) {}\n   * }\n   *\n   * var providers = ReflectiveInjector.resolve([Car, [[Engine]]]);\n   *\n   * expect(providers.length).toEqual(2);\n   *\n   * expect(providers[0] instanceof ResolvedReflectiveProvider).toBe(true);\n   * expect(providers[0].key.displayName).toBe(\"Car\");\n   * expect(providers[0].dependencies.length).toEqual(1);\n   * expect(providers[0].factory).toBeDefined();\n   *\n   * expect(providers[1].key.displayName).toBe(\"Engine\");\n   * });\n   * ```\n   *\n   */\n  static resolve(providers: Provider[]): ResolvedReflectiveProvider[] {\n    return resolveReflectiveProviders(providers);\n  }\n\n  /**\n   * Resolves an array of providers and creates an injector from those providers.\n   *\n   * The passed-in providers can be an array of `Type`, `Provider`,\n   * or a recursive array of more providers.\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * ```typescript\n   * @Injectable()\n   * class Engine {\n   * }\n   *\n   * @Injectable()\n   * class Car {\n   *   constructor(public engine:Engine) {}\n   * }\n   *\n   * var injector = ReflectiveInjector.resolveAndCreate([Car, Engine]);\n   * expect(injector.get(Car) instanceof Car).toBe(true);\n   * ```\n   */\n  static resolveAndCreate(providers: Provider[], parent?: Injector): ReflectiveInjector {\n    const ResolvedReflectiveProviders = ReflectiveInjector.resolve(providers);\n    return ReflectiveInjector.fromResolvedProviders(ResolvedReflectiveProviders, parent);\n  }\n\n  /**\n   * Creates an injector from previously resolved providers.\n   *\n   * This API is the recommended way to construct injectors in performance-sensitive parts.\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * ```typescript\n   * @Injectable()\n   * class Engine {\n   * }\n   *\n   * @Injectable()\n   * class Car {\n   *   constructor(public engine:Engine) {}\n   * }\n   *\n   * var providers = ReflectiveInjector.resolve([Car, Engine]);\n   * var injector = ReflectiveInjector.fromResolvedProviders(providers);\n   * expect(injector.get(Car) instanceof Car).toBe(true);\n   * ```\n   * @experimental\n   */\n  static fromResolvedProviders(providers: ResolvedReflectiveProvider[], parent?: Injector):\n      ReflectiveInjector {\n    return new ReflectiveInjector_(providers, parent);\n  }\n\n\n  /**\n   * Parent of this injector.\n   *\n   * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.\n   * -->\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * ```typescript\n   * var parent = ReflectiveInjector.resolveAndCreate([]);\n   * var child = parent.resolveAndCreateChild([]);\n   * expect(child.parent).toBe(parent);\n   * ```\n   */\n  abstract get parent(): Injector|null;\n\n  /**\n   * Resolves an array of providers and creates a child injector from those providers.\n   *\n   * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.\n   * -->\n   *\n   * The passed-in providers can be an array of `Type`, `Provider`,\n   * or a recursive array of more providers.\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * ```typescript\n   * class ParentProvider {}\n   * class ChildProvider {}\n   *\n   * var parent = ReflectiveInjector.resolveAndCreate([ParentProvider]);\n   * var child = parent.resolveAndCreateChild([ChildProvider]);\n   *\n   * expect(child.get(ParentProvider) instanceof ParentProvider).toBe(true);\n   * expect(child.get(ChildProvider) instanceof ChildProvider).toBe(true);\n   * expect(child.get(ParentProvider)).toBe(parent.get(ParentProvider));\n   * ```\n   */\n  abstract resolveAndCreateChild(providers: Provider[]): ReflectiveInjector;\n\n  /**\n   * Creates a child injector from previously resolved providers.\n   *\n   * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.\n   * -->\n   *\n   * This API is the recommended way to construct injectors in performance-sensitive parts.\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * ```typescript\n   * class ParentProvider {}\n   * class ChildProvider {}\n   *\n   * var parentProviders = ReflectiveInjector.resolve([ParentProvider]);\n   * var childProviders = ReflectiveInjector.resolve([ChildProvider]);\n   *\n   * var parent = ReflectiveInjector.fromResolvedProviders(parentProviders);\n   * var child = parent.createChildFromResolved(childProviders);\n   *\n   * expect(child.get(ParentProvider) instanceof ParentProvider).toBe(true);\n   * expect(child.get(ChildProvider) instanceof ChildProvider).toBe(true);\n   * expect(child.get(ParentProvider)).toBe(parent.get(ParentProvider));\n   * ```\n   */\n  abstract createChildFromResolved(providers: ResolvedReflectiveProvider[]): ReflectiveInjector;\n\n  /**\n   * Resolves a provider and instantiates an object in the context of the injector.\n   *\n   * The created object does not get cached by the injector.\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * ```typescript\n   * @Injectable()\n   * class Engine {\n   * }\n   *\n   * @Injectable()\n   * class Car {\n   *   constructor(public engine:Engine) {}\n   * }\n   *\n   * var injector = ReflectiveInjector.resolveAndCreate([Engine]);\n   *\n   * var car = injector.resolveAndInstantiate(Car);\n   * expect(car.engine).toBe(injector.get(Engine));\n   * expect(car).not.toBe(injector.resolveAndInstantiate(Car));\n   * ```\n   */\n  abstract resolveAndInstantiate(provider: Provider): any;\n\n  /**\n   * Instantiates an object using a resolved provider in the context of the injector.\n   *\n   * The created object does not get cached by the injector.\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * ```typescript\n   * @Injectable()\n   * class Engine {\n   * }\n   *\n   * @Injectable()\n   * class Car {\n   *   constructor(public engine:Engine) {}\n   * }\n   *\n   * var injector = ReflectiveInjector.resolveAndCreate([Engine]);\n   * var carProvider = ReflectiveInjector.resolve([Car])[0];\n   * var car = injector.instantiateResolved(carProvider);\n   * expect(car.engine).toBe(injector.get(Engine));\n   * expect(car).not.toBe(injector.instantiateResolved(carProvider));\n   * ```\n   */\n  abstract instantiateResolved(provider: ResolvedReflectiveProvider): any;\n\n  abstract get(token: any, notFoundValue?: any): any;\n}\n\nexport class ReflectiveInjector_ implements ReflectiveInjector {\n  private static INJECTOR_KEY = ReflectiveKey.get(Injector);\n  /** @internal */\n  _constructionCounter: number = 0;\n  /** @internal */\n  public _providers: ResolvedReflectiveProvider[];\n  public readonly parent: Injector|null;\n\n  keyIds: number[];\n  objs: any[];\n  /**\n   * Private\n   */\n  constructor(_providers: ResolvedReflectiveProvider[], _parent?: Injector) {\n    this._providers = _providers;\n    this.parent = _parent || null;\n\n    const len = _providers.length;\n\n    this.keyIds = new Array(len);\n    this.objs = new Array(len);\n\n    for (let i = 0; i < len; i++) {\n      this.keyIds[i] = _providers[i].key.id;\n      this.objs[i] = UNDEFINED;\n    }\n  }\n\n  get(token: any, notFoundValue: any = THROW_IF_NOT_FOUND): any {\n    return this._getByKey(ReflectiveKey.get(token), null, notFoundValue);\n  }\n\n  resolveAndCreateChild(providers: Provider[]): ReflectiveInjector {\n    const ResolvedReflectiveProviders = ReflectiveInjector.resolve(providers);\n    return this.createChildFromResolved(ResolvedReflectiveProviders);\n  }\n\n  createChildFromResolved(providers: ResolvedReflectiveProvider[]): ReflectiveInjector {\n    const inj = new ReflectiveInjector_(providers);\n    (inj as{parent: Injector | null}).parent = this;\n    return inj;\n  }\n\n  resolveAndInstantiate(provider: Provider): any {\n    return this.instantiateResolved(ReflectiveInjector.resolve([provider])[0]);\n  }\n\n  instantiateResolved(provider: ResolvedReflectiveProvider): any {\n    return this._instantiateProvider(provider);\n  }\n\n  getProviderAtIndex(index: number): ResolvedReflectiveProvider {\n    if (index < 0 || index >= this._providers.length) {\n      throw outOfBoundsError(index);\n    }\n    return this._providers[index];\n  }\n\n  /** @internal */\n  _new(provider: ResolvedReflectiveProvider): any {\n    if (this._constructionCounter++ > this._getMaxNumberOfObjects()) {\n      throw cyclicDependencyError(this, provider.key);\n    }\n    return this._instantiateProvider(provider);\n  }\n\n  private _getMaxNumberOfObjects(): number { return this.objs.length; }\n\n  private _instantiateProvider(provider: ResolvedReflectiveProvider): any {\n    if (provider.multiProvider) {\n      const res = new Array(provider.resolvedFactories.length);\n      for (let i = 0; i < provider.resolvedFactories.length; ++i) {\n        res[i] = this._instantiate(provider, provider.resolvedFactories[i]);\n      }\n      return res;\n    } else {\n      return this._instantiate(provider, provider.resolvedFactories[0]);\n    }\n  }\n\n  private _instantiate(\n      provider: ResolvedReflectiveProvider,\n      ResolvedReflectiveFactory: ResolvedReflectiveFactory): any {\n    const factory = ResolvedReflectiveFactory.factory;\n\n    let deps: any[];\n    try {\n      deps =\n          ResolvedReflectiveFactory.dependencies.map(dep => this._getByReflectiveDependency(dep));\n    } catch (e) {\n      if (e.addKey) {\n        e.addKey(this, provider.key);\n      }\n      throw e;\n    }\n\n    let obj: any;\n    try {\n      obj = factory(...deps);\n    } catch (e) {\n      throw instantiationError(this, e, e.stack, provider.key);\n    }\n\n    return obj;\n  }\n\n  private _getByReflectiveDependency(dep: ReflectiveDependency): any {\n    return this._getByKey(dep.key, dep.visibility, dep.optional ? null : THROW_IF_NOT_FOUND);\n  }\n\n  private _getByKey(key: ReflectiveKey, visibility: Self|SkipSelf|null, notFoundValue: any): any {\n    if (key === ReflectiveInjector_.INJECTOR_KEY) {\n      return this;\n    }\n\n    if (visibility instanceof Self) {\n      return this._getByKeySelf(key, notFoundValue);\n\n    } else {\n      return this._getByKeyDefault(key, notFoundValue, visibility);\n    }\n  }\n\n  private _getObjByKeyId(keyId: number): any {\n    for (let i = 0; i < this.keyIds.length; i++) {\n      if (this.keyIds[i] === keyId) {\n        if (this.objs[i] === UNDEFINED) {\n          this.objs[i] = this._new(this._providers[i]);\n        }\n\n        return this.objs[i];\n      }\n    }\n\n    return UNDEFINED;\n  }\n\n  /** @internal */\n  _throwOrNull(key: ReflectiveKey, notFoundValue: any): any {\n    if (notFoundValue !== THROW_IF_NOT_FOUND) {\n      return notFoundValue;\n    } else {\n      throw noProviderError(this, key);\n    }\n  }\n\n  /** @internal */\n  _getByKeySelf(key: ReflectiveKey, notFoundValue: any): any {\n    const obj = this._getObjByKeyId(key.id);\n    return (obj !== UNDEFINED) ? obj : this._throwOrNull(key, notFoundValue);\n  }\n\n  /** @internal */\n  _getByKeyDefault(key: ReflectiveKey, notFoundValue: any, visibility: Self|SkipSelf|null): any {\n    let inj: Injector|null;\n\n    if (visibility instanceof SkipSelf) {\n      inj = this.parent;\n    } else {\n      inj = this;\n    }\n\n    while (inj instanceof ReflectiveInjector_) {\n      const inj_ = <ReflectiveInjector_>inj;\n      const obj = inj_._getObjByKeyId(key.id);\n      if (obj !== UNDEFINED) return obj;\n      inj = inj_.parent;\n    }\n    if (inj !== null) {\n      return inj.get(key.token, notFoundValue);\n    } else {\n      return this._throwOrNull(key, notFoundValue);\n    }\n  }\n\n  get displayName(): string {\n    const providers =\n        _mapProviders(this, (b: ResolvedReflectiveProvider) => ' \"' + b.key.displayName + '\" ')\n            .join(', ');\n    return `ReflectiveInjector(providers: [${providers}])`;\n  }\n\n  toString(): string { return this.displayName; }\n}\n\nfunction _mapProviders(injector: ReflectiveInjector_, fn: Function): any[] {\n  const res: any[] = new Array(injector._providers.length);\n  for (let i = 0; i < injector._providers.length; ++i) {\n    res[i] = fn(injector.getProviderAtIndex(i));\n  }\n  return res;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Type} from '../type';\nimport {InjectionToken} from './injection_token';\n\n\n/**\n * An internal token whose presence in an injector indicates that the injector should treat itself\n * as a root scoped injector when processing requests for unknown tokens which may indicate\n * they are provided in the root scope.\n */\nexport const APP_ROOT = new InjectionToken<boolean>(\n    'The presence of this token marks an injector as being the root injector.');\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {OnDestroy} from '../metadata/lifecycle_hooks';\nimport {Type} from '../type';\nimport {stringify} from '../util';\n\nimport {InjectableDef, InjectableType, InjectorDef, InjectorType, InjectorTypeWithProviders} from './defs';\nimport {resolveForwardRef} from './forward_ref';\nimport {InjectableDefToken, InjectionToken} from './injection_token';\nimport {INJECTOR, InjectFlags, Injector, NullInjector, THROW_IF_NOT_FOUND, USE_VALUE, inject, injectArgs, setCurrentInjector} from './injector';\nimport {ClassProvider, ConstructorProvider, ExistingProvider, FactoryProvider, Provider, StaticClassProvider, TypeProvider, ValueProvider} from './provider';\nimport {APP_ROOT} from './scope';\n\n\n\n/**\n * Internal type for a single provider in a deep provider array.\n */\ntype SingleProvider = TypeProvider | ValueProvider | ClassProvider | ConstructorProvider |\n    ExistingProvider | FactoryProvider | StaticClassProvider;\n\n/**\n * Marker which indicates that a value has not yet been created from the factory function.\n */\nconst NOT_YET = {};\n\n/**\n * Marker which indicates that the factory function for a token is in the process of being called.\n *\n * If the injector is asked to inject a token with its value set to CIRCULAR, that indicates\n * injection of a dependency has recursively attempted to inject the original token, and there is\n * a circular dependency among the providers.\n */\nconst CIRCULAR = {};\n\nconst EMPTY_ARRAY = [] as any[];\n\n/**\n * A lazily initialized NullInjector.\n */\nlet NULL_INJECTOR: Injector|undefined = undefined;\n\nfunction getNullInjector(): Injector {\n  if (NULL_INJECTOR === undefined) {\n    NULL_INJECTOR = new NullInjector();\n  }\n  return NULL_INJECTOR;\n}\n\n/**\n * An entry in the injector which tracks information about the given token, including a possible\n * current value.\n */\ninterface Record<T> {\n  factory: (() => T)|undefined;\n  value: T|{};\n  multi: any[]|undefined;\n}\n\n/**\n * Create a new `Injector` which is configured using `InjectorType`s.\n *\n * @experimental\n */\nexport function createInjector(\n    defType: /* InjectorType<any> */ any, parent: Injector | null = null): Injector {\n  parent = parent || getNullInjector();\n  return new R3Injector(defType, parent);\n}\n\nexport class R3Injector {\n  /**\n   * Map of tokens to records which contain the instances of those tokens.\n   */\n  private records = new Map<Type<any>|InjectionToken<any>, Record<any>>();\n\n  /**\n   * The transitive set of `InjectorType`s which define this injector.\n   */\n  private injectorDefTypes = new Set<InjectorType<any>>();\n\n  /**\n   * Set of values instantiated by this injector which contain `ngOnDestroy` lifecycle hooks.\n   */\n  private onDestroy = new Set<OnDestroy>();\n\n  /**\n   * Flag indicating this injector provides the APP_ROOT_SCOPE token, and thus counts as the\n   * root scope.\n   */\n  private readonly isRootInjector: boolean;\n\n  /**\n   * Flag indicating that this injector was previously destroyed.\n   */\n  private destroyed = false;\n\n  constructor(def: InjectorType<any>, readonly parent: Injector) {\n    // Start off by creating Records for every provider declared in every InjectorType\n    // included transitively in `def`.\n    deepForEach(\n        [def], injectorDef => this.processInjectorType(injectorDef, new Set<InjectorType<any>>()));\n\n    // Make sure the INJECTOR token provides this injector.\n    this.records.set(INJECTOR, makeRecord(undefined, this));\n\n    // Detect whether this injector has the APP_ROOT_SCOPE token and thus should provide\n    // any injectable scoped to APP_ROOT_SCOPE.\n    this.isRootInjector = this.records.has(APP_ROOT);\n\n    // Eagerly instantiate the InjectorType classes themselves.\n    this.injectorDefTypes.forEach(defType => this.get(defType));\n  }\n\n  /**\n   * Destroy the injector and release references to every instance or provider associated with it.\n   *\n   * Also calls the `OnDestroy` lifecycle hooks of every instance that was created for which a\n   * hook was found.\n   */\n  destroy(): void {\n    this.assertNotDestroyed();\n\n    // Set destroyed = true first, in case lifecycle hooks re-enter destroy().\n    this.destroyed = true;\n    try {\n      // Call all the lifecycle hooks.\n      this.onDestroy.forEach(service => service.ngOnDestroy());\n    } finally {\n      // Release all references.\n      this.records.clear();\n      this.onDestroy.clear();\n      this.injectorDefTypes.clear();\n    }\n  }\n\n  get<T>(\n      token: Type<T>|InjectionToken<T>, notFoundValue: any = THROW_IF_NOT_FOUND,\n      flags = InjectFlags.Default): T {\n    this.assertNotDestroyed();\n    // Set the injection context.\n    const previousInjector = setCurrentInjector(this);\n    try {\n      // Check for the SkipSelf flag.\n      if (!(flags & InjectFlags.SkipSelf)) {\n        // SkipSelf isn't set, check if the record belongs to this injector.\n        let record: Record<T>|undefined = this.records.get(token);\n        if (record === undefined) {\n          // No record, but maybe the token is scoped to this injector. Look for an ngInjectableDef\n          // with a scope matching this injector.\n          const def = couldBeInjectableType(token) &&\n                  (token as InjectableType<any>| InjectableDefToken<any>).ngInjectableDef ||\n              undefined;\n          if (def !== undefined && this.injectableDefInScope(def)) {\n            // Found an ngInjectableDef and it's scoped to this injector. Pretend as if it was here\n            // all along.\n            record = injectableDefRecord(token);\n            this.records.set(token, record);\n          }\n        }\n        // If a record was found, get the instance for it and return it.\n        if (record !== undefined) {\n          return this.hydrate(token, record);\n        }\n      }\n\n      // Select the next injector based on the Self flag - if self is set, the next injector is\n      // the NullInjector, otherwise it's the parent.\n      let next = !(flags & InjectFlags.Self) ? this.parent : getNullInjector();\n      return this.parent.get(token, notFoundValue);\n    } finally {\n      // Lastly, clean up the state by restoring the previous injector.\n      setCurrentInjector(previousInjector);\n    }\n  }\n\n  private assertNotDestroyed(): void {\n    if (this.destroyed) {\n      throw new Error('Injector has already been destroyed.');\n    }\n  }\n\n  /**\n   * Add an `InjectorType` or `InjectorDefTypeWithProviders` and all of its transitive providers\n   * to this injector.\n   */\n  private processInjectorType(\n      defOrWrappedDef: InjectorType<any>|InjectorTypeWithProviders<any>,\n      parents: Set<InjectorType<any>>) {\n    defOrWrappedDef = resolveForwardRef(defOrWrappedDef);\n\n    // Either the defOrWrappedDef is an InjectorType (with ngInjectorDef) or an\n    // InjectorDefTypeWithProviders (aka ModuleWithProviders). Detecting either is a megamorphic\n    // read, so care is taken to only do the read once.\n\n    // First attempt to read the ngInjectorDef.\n    let def = (defOrWrappedDef as InjectorType<any>).ngInjectorDef as(InjectorDef<any>| undefined);\n\n    // If that's not present, then attempt to read ngModule from the InjectorDefTypeWithProviders.\n    const ngModule =\n        (def == null) && (defOrWrappedDef as InjectorTypeWithProviders<any>).ngModule || undefined;\n\n    // Determine the InjectorType. In the case where `defOrWrappedDef` is an `InjectorType`,\n    // then this is easy. In the case of an InjectorDefTypeWithProviders, then the definition type\n    // is the `ngModule`.\n    const defType: InjectorType<any> =\n        (ngModule === undefined) ? (defOrWrappedDef as InjectorType<any>) : ngModule;\n\n    // If defOrWrappedType was an InjectorDefTypeWithProviders, then .providers may hold some\n    // extra providers.\n    const providers =\n        (ngModule !== undefined) && (defOrWrappedDef as InjectorTypeWithProviders<any>).providers ||\n        EMPTY_ARRAY;\n\n    // Finally, if defOrWrappedType was an `InjectorDefTypeWithProviders`, then the actual\n    // `InjectorDef` is on its `ngModule`.\n    if (ngModule !== undefined) {\n      def = ngModule.ngInjectorDef;\n    }\n\n    // If no definition was found, throw.\n    if (def == null) {\n      throw new Error(`Type ${stringify(defType)} is missing an ngInjectorDef definition.`);\n    }\n\n    // Check for circular dependencies.\n    if (parents.has(defType)) {\n      throw new Error(`Circular dependency: type ${stringify(defType)} ends up importing itself.`);\n    }\n\n    // Track the InjectorType and add a provider for it.\n    this.injectorDefTypes.add(defType);\n    this.records.set(defType, makeRecord(def.factory));\n\n    // Add providers in the same way that @NgModule resolution did:\n\n    // First, include providers from any imports.\n    if (def.imports != null) {\n      // Before processing defType's imports, add it to the set of parents. This way, if it ends\n      // up deeply importing itself, this can be detected.\n      parents.add(defType);\n      try {\n        deepForEach(def.imports, imported => this.processInjectorType(imported, parents));\n      } finally {\n        // Remove it from the parents set when finished.\n        parents.delete(defType);\n      }\n    }\n\n    // Next, include providers listed on the definition itself.\n    if (def.providers != null) {\n      deepForEach(def.providers, provider => this.processProvider(provider));\n    }\n\n    // Finally, include providers from an InjectorDefTypeWithProviders if there was one.\n    deepForEach(providers, provider => this.processProvider(provider));\n  }\n\n  /**\n   * Process a `SingleProvider` and add it.\n   */\n  private processProvider(provider: SingleProvider): void {\n    // Determine the token from the provider. Either it's its own token, or has a {provide: ...}\n    // property.\n    provider = resolveForwardRef(provider);\n    let token: any = isTypeProvider(provider) ? provider : resolveForwardRef(provider.provide);\n\n    // Construct a `Record` for the provider.\n    const record = providerToRecord(provider);\n\n    if (!isTypeProvider(provider) && provider.multi === true) {\n      // If the provider indicates that it's a multi-provider, process it specially.\n      // First check whether it's been defined already.\n      let multiRecord = this.records.get(token);\n      if (multiRecord) {\n        // It has. Throw a nice error if\n        if (multiRecord.multi === undefined) {\n          throw new Error(`Mixed multi-provider for ${token}.`);\n        }\n      } else {\n        token = provider;\n        multiRecord = makeRecord(undefined, NOT_YET, true);\n        multiRecord.factory = () => injectArgs(multiRecord !.multi !);\n        this.records.set(token, multiRecord);\n      }\n      token = provider;\n      multiRecord.multi !.push(provider);\n    }\n\n    const existing = this.records.get(token);\n    if (existing && existing.multi !== undefined) {\n      throw new Error(`Mixed multi-provider for ${token}`);\n    }\n\n    this.records.set(token, record);\n  }\n\n  private hydrate<T>(token: Type<T>|InjectionToken<T>, record: Record<T>): T {\n    if (record.value === CIRCULAR) {\n      throw new Error(`Circular dep for ${stringify(token)}`);\n    } else if (record.value === NOT_YET) {\n      record.value = CIRCULAR;\n      record.value = record.factory !();\n    }\n    if (typeof record.value === 'object' && record.value && hasOnDestroy(record.value)) {\n      this.onDestroy.add(record.value);\n    }\n    return record.value as T;\n  }\n\n  private injectableDefInScope(def: InjectableDef<any>): boolean {\n    if (!def.providedIn) {\n      return false;\n    } else if (typeof def.providedIn === 'string') {\n      return def.providedIn === 'any' || (def.providedIn === 'root' && this.isRootInjector);\n    } else {\n      return this.injectorDefTypes.has(def.providedIn);\n    }\n  }\n}\n\nfunction injectableDefRecord(token: Type<any>| InjectionToken<any>): Record<any> {\n  const def = (token as InjectableType<any>).ngInjectableDef as InjectableDef<any>;\n  if (def === undefined) {\n    throw new Error(`Type ${stringify(token)} is missing an ngInjectableDef definition.`);\n  }\n  return makeRecord(def.factory);\n}\n\nfunction providerToRecord(provider: SingleProvider): Record<any> {\n  let token = resolveForwardRef(provider);\n  let value: any = NOT_YET;\n  let factory: (() => any)|undefined = undefined;\n  if (isTypeProvider(provider)) {\n    return injectableDefRecord(provider);\n  } else {\n    token = resolveForwardRef(provider.provide);\n    if (isValueProvider(provider)) {\n      value = provider.useValue;\n    } else if (isExistingProvider(provider)) {\n      factory = () => inject(provider.useExisting);\n    } else if (isFactoryProvider(provider)) {\n      factory = () => provider.useFactory(...injectArgs(provider.deps || []));\n    } else {\n      const classRef = (provider as StaticClassProvider | ClassProvider).useClass || token;\n      if (hasDeps(provider)) {\n        factory = () => new (classRef)(...injectArgs(provider.deps));\n      } else {\n        return injectableDefRecord(classRef);\n      }\n    }\n  }\n  return makeRecord(factory, value);\n}\n\nfunction makeRecord<T>(\n    factory: (() => T) | undefined, value: T | {} = NOT_YET, multi: boolean = false): Record<T> {\n  return {\n    factory: factory,\n    value: value,\n    multi: multi ? [] : undefined,\n  };\n}\n\nfunction deepForEach<T>(input: (T | any[])[], fn: (value: T) => void): void {\n  input.forEach(value => Array.isArray(value) ? deepForEach(value, fn) : fn(value));\n}\n\nfunction isValueProvider(value: SingleProvider): value is ValueProvider {\n  return USE_VALUE in value;\n}\n\nfunction isExistingProvider(value: SingleProvider): value is ExistingProvider {\n  return !!(value as ExistingProvider).useExisting;\n}\n\nfunction isFactoryProvider(value: SingleProvider): value is FactoryProvider {\n  return !!(value as FactoryProvider).useFactory;\n}\n\nfunction isClassProvider(value: SingleProvider): value is ClassProvider {\n  return !!(value as ClassProvider).useClass;\n}\n\nfunction isTypeProvider(value: SingleProvider): value is TypeProvider {\n  return typeof value === 'function';\n}\n\nfunction hasDeps(value: ClassProvider | ConstructorProvider | StaticClassProvider):\n    value is ClassProvider&{deps: any[]} {\n  return !!(value as any).deps;\n}\n\nfunction hasOnDestroy(value: any): value is OnDestroy {\n  return typeof value === 'object' && value != null && (value as OnDestroy).ngOnDestroy &&\n      typeof(value as OnDestroy).ngOnDestroy === 'function';\n}\n\nfunction couldBeInjectableType(value: any): value is Type<any>|InjectionToken<any> {\n  return (typeof value === 'function') ||\n      (typeof value === 'object' && value instanceof InjectionToken);\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @module\n * @description\n * The `di` module provides dependency injection container services.\n */\n\nexport * from './di/metadata';\nexport {InjectableType, InjectorType, defineInjectable, defineInjector} from './di/defs';\nexport {forwardRef, resolveForwardRef, ForwardRefFn} from './di/forward_ref';\nexport {Injectable, InjectableDecorator, InjectableProvider} from './di/injectable';\nexport {inject, InjectFlags, INJECTOR, Injector} from './di/injector';\nexport {ReflectiveInjector} from './di/reflective_injector';\nexport {StaticProvider, ValueProvider, ExistingProvider, FactoryProvider, Provider, TypeProvider, ClassProvider} from './di/provider';\nexport {createInjector} from './di/r3_injector';\nexport {ResolvedReflectiveFactory, ResolvedReflectiveProvider} from './di/reflective_provider';\nexport {ReflectiveKey} from './di/reflective_key';\nexport {InjectionToken} from './di/injection_token';\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Observable} from 'rxjs';\n\n/**\n * Determine if the argument is shaped like a Promise\n */\nexport function isPromise(obj: any): obj is Promise<any> {\n  // allow any Promise/A+ compliant thenable.\n  // It's up to the caller to ensure that obj.then conforms to the spec\n  return !!obj && typeof obj.then === 'function';\n}\n\n/**\n * Determine if the argument is an Observable\n */\nexport function isObservable(obj: any | Observable<any>): obj is Observable<any> {\n  // TODO: use Symbol.observable when https://github.com/ReactiveX/rxjs/issues/2415 will be resolved\n  return !!obj && typeof obj.subscribe === 'function';\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {isPromise} from '../src/util/lang';\n\nimport {Inject, Injectable, InjectionToken, Optional} from './di';\n\n\n/**\n * A function that will be executed when an application is initialized.\n * @experimental\n */\nexport const APP_INITIALIZER = new InjectionToken<Array<() => void>>('Application Initializer');\n\n/**\n * A class that reflects the state of running {@link APP_INITIALIZER}s.\n *\n * @experimental\n */\n@Injectable()\nexport class ApplicationInitStatus {\n  private resolve: Function;\n  private reject: Function;\n  private initialized = false;\n  public readonly donePromise: Promise<any>;\n  public readonly done = false;\n\n  constructor(@Inject(APP_INITIALIZER) @Optional() private appInits: (() => any)[]) {\n    this.donePromise = new Promise((res, rej) => {\n      this.resolve = res;\n      this.reject = rej;\n    });\n  }\n\n  /** @internal */\n  runInitializers() {\n    if (this.initialized) {\n      return;\n    }\n\n    const asyncInitPromises: Promise<any>[] = [];\n\n    const complete = () => {\n      (this as{done: boolean}).done = true;\n      this.resolve();\n    };\n\n    if (this.appInits) {\n      for (let i = 0; i < this.appInits.length; i++) {\n        const initResult = this.appInits[i]();\n        if (isPromise(initResult)) {\n          asyncInitPromises.push(initResult);\n        }\n      }\n    }\n\n    Promise.all(asyncInitPromises).then(() => { complete(); }).catch(e => { this.reject(e); });\n\n    if (asyncInitPromises.length === 0) {\n      complete();\n    }\n    this.initialized = true;\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {InjectionToken} from './di';\nimport {ComponentRef} from './linker/component_factory';\n\n\n/**\n * A DI Token representing a unique string id assigned to the application by Angular and used\n * primarily for prefixing application attributes and CSS styles when\n * {@link ViewEncapsulation#Emulated ViewEncapsulation.Emulated} is being used.\n *\n * If you need to avoid randomly generated value to be used as an application id, you can provide\n * a custom value via a DI provider <!-- TODO: provider --> configuring the root {@link Injector}\n * using this token.\n * @experimental\n */\nexport const APP_ID = new InjectionToken<string>('AppId');\n\nexport function _appIdRandomProviderFactory() {\n  return `${_randomChar()}${_randomChar()}${_randomChar()}`;\n}\n\n/**\n * Providers that will generate a random APP_ID_TOKEN.\n * @experimental\n */\nexport const APP_ID_RANDOM_PROVIDER = {\n  provide: APP_ID,\n  useFactory: _appIdRandomProviderFactory,\n  deps: <any[]>[],\n};\n\nfunction _randomChar(): string {\n  return String.fromCharCode(97 + Math.floor(Math.random() * 25));\n}\n\n/**\n * A function that will be executed when a platform is initialized.\n * @experimental\n */\nexport const PLATFORM_INITIALIZER = new InjectionToken<Array<() => void>>('Platform Initializer');\n\n/**\n * A token that indicates an opaque platform id.\n * @experimental\n */\nexport const PLATFORM_ID = new InjectionToken<Object>('Platform ID');\n\n/**\n * All callbacks provided via this token will be called for every component that is bootstrapped.\n * Signature of the callback:\n *\n * `(componentRef: ComponentRef) => void`.\n *\n * @experimental\n */\nexport const APP_BOOTSTRAP_LISTENER =\n    new InjectionToken<Array<(compRef: ComponentRef<any>) => void>>('appBootstrapListener');\n\n/**\n * A token which indicates the root directory of the application\n * @experimental\n */\nexport const PACKAGE_ROOT_URL = new InjectionToken<string>('Application Packages Root URL');\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injectable} from './di';\n\n@Injectable()\nexport class Console {\n  log(message: string): void {\n    // tslint:disable-next-line:no-console\n    console.log(message);\n  }\n  // Note: for reporting errors use `DOM.logError()` as it is platform specific\n  warn(message: string): void {\n    // tslint:disable-next-line:no-console\n    console.warn(message);\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injectable, InjectionToken, StaticProvider} from '../di';\nimport {MissingTranslationStrategy} from '../i18n/tokens';\nimport {ViewEncapsulation} from '../metadata';\nimport {Type} from '../type';\n\nimport {ComponentFactory} from './component_factory';\nimport {NgModuleFactory} from './ng_module_factory';\n\n\n/**\n * Combination of NgModuleFactory and ComponentFactorys.\n *\n * @experimental\n */\nexport class ModuleWithComponentFactories<T> {\n  constructor(\n      public ngModuleFactory: NgModuleFactory<T>,\n      public componentFactories: ComponentFactory<any>[]) {}\n}\n\n\nfunction _throwError() {\n  throw new Error(`Runtime compiler is not loaded`);\n}\n\n/**\n * Low-level service for running the angular compiler during runtime\n * to create {@link ComponentFactory}s, which\n * can later be used to create and render a Component instance.\n *\n * Each `@NgModule` provides an own `Compiler` to its injector,\n * that will use the directives/pipes of the ng module for compilation\n * of components.\n *\n */\n@Injectable()\nexport class Compiler {\n  /**\n   * Compiles the given NgModule and all of its components. All templates of the components listed\n   * in `entryComponents` have to be inlined.\n   */\n  compileModuleSync<T>(moduleType: Type<T>): NgModuleFactory<T> { throw _throwError(); }\n\n  /**\n   * Compiles the given NgModule and all of its components\n   */\n  compileModuleAsync<T>(moduleType: Type<T>): Promise<NgModuleFactory<T>> { throw _throwError(); }\n\n  /**\n   * Same as {@link #compileModuleSync} but also creates ComponentFactories for all components.\n   */\n  compileModuleAndAllComponentsSync<T>(moduleType: Type<T>): ModuleWithComponentFactories<T> {\n    throw _throwError();\n  }\n\n  /**\n   * Same as {@link #compileModuleAsync} but also creates ComponentFactories for all components.\n   */\n  compileModuleAndAllComponentsAsync<T>(moduleType: Type<T>):\n      Promise<ModuleWithComponentFactories<T>> {\n    throw _throwError();\n  }\n\n  /**\n   * Clears all caches.\n   */\n  clearCache(): void {}\n\n  /**\n   * Clears the cache for the given component/ngModule.\n   */\n  clearCacheFor(type: Type<any>) {}\n}\n\n/**\n * Options for creating a compiler\n *\n * @experimental\n */\nexport type CompilerOptions = {\n  useJit?: boolean,\n  defaultEncapsulation?: ViewEncapsulation,\n  providers?: StaticProvider[],\n  missingTranslation?: MissingTranslationStrategy,\n  preserveWhitespaces?: boolean,\n};\n\n/**\n * Token to provide CompilerOptions in the platform injector.\n *\n * @experimental\n */\nexport const COMPILER_OPTIONS = new InjectionToken<CompilerOptions[]>('compilerOptions');\n\n/**\n * A factory for creating a Compiler\n *\n * @experimental\n */\nexport abstract class CompilerFactory {\n  abstract createCompiler(options?: CompilerOptions[]): Compiler;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ChangeDetectorRef} from '../change_detection/change_detection';\nimport {Injector} from '../di/injector';\nimport {Type} from '../type';\n\nimport {ElementRef} from './element_ref';\nimport {NgModuleRef} from './ng_module_factory';\nimport {ViewRef} from './view_ref';\n\n/**\n * Represents an instance of a Component created via a {@link ComponentFactory}.\n *\n * `ComponentRef` provides access to the Component Instance as well other objects related to this\n * Component Instance and allows you to destroy the Component Instance via the {@link #destroy}\n * method.\n *\n */\nexport abstract class ComponentRef<C> {\n  /**\n   * Location of the Host Element of this Component Instance.\n   */\n  abstract get location(): ElementRef;\n\n  /**\n   * The injector on which the component instance exists.\n   */\n  abstract get injector(): Injector;\n\n  /**\n   * The instance of the Component.\n   */\n  abstract get instance(): C;\n\n  /**\n   * The {@link ViewRef} of the Host View of this Component instance.\n   */\n  abstract get hostView(): ViewRef;\n\n  /**\n   * The {@link ChangeDetectorRef} of the Component instance.\n   */\n  abstract get changeDetectorRef(): ChangeDetectorRef;\n\n  /**\n   * The component type.\n   */\n  abstract get componentType(): Type<any>;\n\n  /**\n   * Destroys the component instance and all of the data structures associated with it.\n   */\n  abstract destroy(): void;\n\n  /**\n   * Allows to register a callback that will be called when the component is destroyed.\n   */\n  abstract onDestroy(callback: Function): void;\n}\n\nexport abstract class ComponentFactory<C> {\n  abstract get selector(): string;\n  abstract get componentType(): Type<any>;\n  /**\n   * selector for all <ng-content> elements in the component.\n   */\n  abstract get ngContentSelectors(): string[];\n  /**\n   * the inputs of the component.\n   */\n  abstract get inputs(): {propName: string, templateName: string}[];\n  /**\n   * the outputs of the component.\n   */\n  abstract get outputs(): {propName: string, templateName: string}[];\n  /**\n   * Creates a new component.\n   */\n  abstract create(\n      injector: Injector, projectableNodes?: any[][], rootSelectorOrNode?: string|any,\n      ngModule?: NgModuleRef<any>): ComponentRef<C>;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injector} from '../di/injector';\nimport {Type} from '../type';\nimport {stringify} from '../util';\n\nimport {ComponentFactory, ComponentRef} from './component_factory';\nimport {NgModuleRef} from './ng_module_factory';\n\nexport function noComponentFactoryError(component: Function) {\n  const error = Error(\n      `No component factory found for ${stringify(component)}. Did you add it to @NgModule.entryComponents?`);\n  (error as any)[ERROR_COMPONENT] = component;\n  return error;\n}\n\nconst ERROR_COMPONENT = 'ngComponent';\n\nexport function getComponent(error: Error): Type<any> {\n  return (error as any)[ERROR_COMPONENT];\n}\n\n\nclass _NullComponentFactoryResolver implements ComponentFactoryResolver {\n  resolveComponentFactory<T>(component: {new (...args: any[]): T}): ComponentFactory<T> {\n    throw noComponentFactoryError(component);\n  }\n}\n\nexport abstract class ComponentFactoryResolver {\n  static NULL: ComponentFactoryResolver = new _NullComponentFactoryResolver();\n  abstract resolveComponentFactory<T>(component: Type<T>): ComponentFactory<T>;\n}\n\nexport class CodegenComponentFactoryResolver implements ComponentFactoryResolver {\n  private _factories = new Map<any, ComponentFactory<any>>();\n\n  constructor(\n      factories: ComponentFactory<any>[], private _parent: ComponentFactoryResolver,\n      private _ngModule: NgModuleRef<any>) {\n    for (let i = 0; i < factories.length; i++) {\n      const factory = factories[i];\n      this._factories.set(factory.componentType, factory);\n    }\n  }\n\n  resolveComponentFactory<T>(component: {new (...args: any[]): T}): ComponentFactory<T> {\n    let factory = this._factories.get(component);\n    if (!factory && this._parent) {\n      factory = this._parent.resolveComponentFactory(component);\n    }\n    if (!factory) {\n      throw noComponentFactoryError(component);\n    }\n    return new ComponentFactoryBoundToModule(factory, this._ngModule);\n  }\n}\n\nexport class ComponentFactoryBoundToModule<C> extends ComponentFactory<C> {\n  readonly selector: string;\n  readonly componentType: Type<any>;\n  readonly ngContentSelectors: string[];\n  readonly inputs: {propName: string, templateName: string}[];\n  readonly outputs: {propName: string, templateName: string}[];\n\n  constructor(private factory: ComponentFactory<C>, private ngModule: NgModuleRef<any>) {\n    super();\n    this.selector = factory.selector;\n    this.componentType = factory.componentType;\n    this.ngContentSelectors = factory.ngContentSelectors;\n    this.inputs = factory.inputs;\n    this.outputs = factory.outputs;\n  }\n\n  create(\n      injector: Injector, projectableNodes?: any[][], rootSelectorOrNode?: string|any,\n      ngModule?: NgModuleRef<any>): ComponentRef<C> {\n    return this.factory.create(\n        injector, projectableNodes, rootSelectorOrNode, ngModule || this.ngModule);\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injector} from '../di/injector';\nimport {Type} from '../type';\n\nimport {ComponentFactoryResolver} from './component_factory_resolver';\n\n\n/**\n * Represents an instance of an NgModule created via a {@link NgModuleFactory}.\n *\n * `NgModuleRef` provides access to the NgModule Instance as well other objects related to this\n * NgModule Instance.\n *\n *\n */\nexport abstract class NgModuleRef<T> {\n  /**\n   * The injector that contains all of the providers of the NgModule.\n   */\n  abstract get injector(): Injector;\n\n  /**\n   * The ComponentFactoryResolver to get hold of the ComponentFactories\n   * declared in the `entryComponents` property of the module.\n   */\n  abstract get componentFactoryResolver(): ComponentFactoryResolver;\n\n  /**\n   * The NgModule instance.\n   */\n  abstract get instance(): T;\n\n  /**\n   * Destroys the module instance and all of the data structures associated with it.\n   */\n  abstract destroy(): void;\n\n  /**\n   * Allows to register a callback that will be called when the module is destroyed.\n   */\n  abstract onDestroy(callback: () => void): void;\n}\n\nexport interface InternalNgModuleRef<T> extends NgModuleRef<T> {\n  // Note: we are using the prefix _ as NgModuleData is an NgModuleRef and therefore directly\n  // exposed to the user.\n  _bootstrapComponents: Type<any>[];\n}\n\n/**\n * @experimental\n */\nexport abstract class NgModuleFactory<T> {\n  abstract get moduleType(): Type<T>;\n  abstract create(parentInjector: Injector|null): NgModuleRef<T>;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {global} from '../util';\n\n/**\n * A scope function for the Web Tracing Framework (WTF).\n *\n * @experimental\n */\nexport interface WtfScopeFn { (arg0?: any, arg1?: any): any; }\n\ninterface WTF {\n  trace: Trace;\n}\n\ninterface Trace {\n  events: Events;\n  leaveScope(scope: Scope, returnValue: any): any /** TODO #9100 */;\n  beginTimeRange(rangeType: string, action: string): Range;\n  endTimeRange(range: Range): any /** TODO #9100 */;\n}\n\nexport interface Range {}\n\ninterface Events {\n  createScope(signature: string, flags: any): Scope;\n}\n\nexport interface Scope { (...args: any[] /** TODO #9100 */): any; }\n\nlet trace: Trace;\nlet events: Events;\n\nexport function detectWTF(): boolean {\n  const wtf: WTF = (global as any /** TODO #9100 */)['wtf'];\n  if (wtf) {\n    trace = wtf['trace'];\n    if (trace) {\n      events = trace['events'];\n      return true;\n    }\n  }\n  return false;\n}\n\nexport function createScope(signature: string, flags: any = null): any {\n  return events.createScope(signature, flags);\n}\n\nexport function leave<T>(scope: Scope): void;\nexport function leave<T>(scope: Scope, returnValue?: T): T;\nexport function leave<T>(scope: Scope, returnValue?: any): any {\n  trace.leaveScope(scope, returnValue);\n  return returnValue;\n}\n\nexport function startTimeRange(rangeType: string, action: string): Range {\n  return trace.beginTimeRange(rangeType, action);\n}\n\nexport function endTimeRange(range: Range): void {\n  trace.endTimeRange(range);\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {WtfScopeFn, createScope, detectWTF, endTimeRange, leave, startTimeRange} from './wtf_impl';\n\nexport {WtfScopeFn} from './wtf_impl';\n\n\n/**\n * True if WTF is enabled.\n */\nexport const wtfEnabled = detectWTF();\n\nfunction noopScope(arg0?: any, arg1?: any): any {\n  return null;\n}\n\n/**\n * Create trace scope.\n *\n * Scopes must be strictly nested and are analogous to stack frames, but\n * do not have to follow the stack frames. Instead it is recommended that they follow logical\n * nesting. You may want to use\n * [Event\n * Signatures](http://google.github.io/tracing-framework/instrumenting-code.html#custom-events)\n * as they are defined in WTF.\n *\n * Used to mark scope entry. The return value is used to leave the scope.\n *\n *     var myScope = wtfCreateScope('MyClass#myMethod(ascii someVal)');\n *\n *     someMethod() {\n *        var s = myScope('Foo'); // 'Foo' gets stored in tracing UI\n *        // DO SOME WORK HERE\n *        return wtfLeave(s, 123); // Return value 123\n *     }\n *\n * Note, adding try-finally block around the work to ensure that `wtfLeave` gets called can\n * negatively impact the performance of your application. For this reason we recommend that\n * you don't add them to ensure that `wtfLeave` gets called. In production `wtfLeave` is a noop and\n * so try-finally block has no value. When debugging perf issues, skipping `wtfLeave`, do to\n * exception, will produce incorrect trace, but presence of exception signifies logic error which\n * needs to be fixed before the app should be profiled. Add try-finally only when you expect that\n * an exception is expected during normal execution while profiling.\n *\n * @experimental\n */\nexport const wtfCreateScope: (signature: string, flags?: any) => WtfScopeFn =\n    wtfEnabled ? createScope : (signature: string, flags?: any) => noopScope;\n\n/**\n * Used to mark end of Scope.\n *\n * - `scope` to end.\n * - `returnValue` (optional) to be passed to the WTF.\n *\n * Returns the `returnValue for easy chaining.\n * @experimental\n */\nexport const wtfLeave: <T>(scope: any, returnValue?: T) => T =\n    wtfEnabled ? leave : (s: any, r?: any) => r;\n\n/**\n * Used to mark Async start. Async are similar to scope but they don't have to be strictly nested.\n * The return value is used in the call to [endAsync]. Async ranges only work if WTF has been\n * enabled.\n *\n *     someMethod() {\n *        var s = wtfStartTimeRange('HTTP:GET', 'some.url');\n *        var future = new Future.delay(5).then((_) {\n *          wtfEndTimeRange(s);\n *        });\n *     }\n * @experimental\n */\nexport const wtfStartTimeRange: (rangeType: string, action: string) => any =\n    wtfEnabled ? startTimeRange : (rangeType: string, action: string) => null;\n\n/**\n * Ends a async time range operation.\n * [range] is the return value from [wtfStartTimeRange] Async ranges only work if WTF has been\n * enabled.\n * @experimental\n */\nexport const wtfEndTimeRange: (range: any) => void = wtfEnabled ? endTimeRange : (r: any) => null;\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Subject, Subscription} from 'rxjs';\n\n/**\n * Use by directives and components to emit custom Events.\n *\n * @usageNotes\n * ### Examples\n *\n * In the following example, `Zippy` alternatively emits `open` and `close` events when its\n * title gets clicked:\n *\n * ```\n * @Component({\n *   selector: 'zippy',\n *   template: `\n *   <div class=\"zippy\">\n *     <div (click)=\"toggle()\">Toggle</div>\n *     <div [hidden]=\"!visible\">\n *       <ng-content></ng-content>\n *     </div>\n *  </div>`})\n * export class Zippy {\n *   visible: boolean = true;\n *   @Output() open: EventEmitter<any> = new EventEmitter();\n *   @Output() close: EventEmitter<any> = new EventEmitter();\n *\n *   toggle() {\n *     this.visible = !this.visible;\n *     if (this.visible) {\n *       this.open.emit(null);\n *     } else {\n *       this.close.emit(null);\n *     }\n *   }\n * }\n * ```\n *\n * The events payload can be accessed by the parameter `$event` on the components output event\n * handler:\n *\n * ```\n * <zippy (open)=\"onOpen($event)\" (close)=\"onClose($event)\"></zippy>\n * ```\n *\n * ### Notes\n *\n * Uses Rx.Observable but provides an adapter to make it work as specified here:\n * https://github.com/jhusain/observable-spec\n *\n * Once a reference implementation of the spec is available, switch to it.\n *\n */\nexport class EventEmitter<T> extends Subject<T> {\n  // TODO: mark this as internal once all the facades are gone\n  // we can't mark it as internal now because EventEmitter exported via @angular/core would not\n  // contain this property making it incompatible with all the code that uses EventEmitter via\n  // facades, which are local to the code and do not have this property stripped.\n  // tslint:disable-next-line\n  __isAsync: boolean;\n\n  /**\n   * Creates an instance of {@link EventEmitter}, which depending on `isAsync`,\n   * delivers events synchronously or asynchronously.\n   *\n   * @param isAsync By default, events are delivered synchronously (default value: `false`).\n   * Set to `true` for asynchronous event delivery.\n   */\n  constructor(isAsync: boolean = false) {\n    super();\n    this.__isAsync = isAsync;\n  }\n\n  emit(value?: T) { super.next(value); }\n\n  subscribe(generatorOrNext?: any, error?: any, complete?: any): any {\n    let schedulerFn: (t: any) => any;\n    let errorFn = (err: any): any => null;\n    let completeFn = (): any => null;\n\n    if (generatorOrNext && typeof generatorOrNext === 'object') {\n      schedulerFn = this.__isAsync ? (value: any) => {\n        setTimeout(() => generatorOrNext.next(value));\n      } : (value: any) => { generatorOrNext.next(value); };\n\n      if (generatorOrNext.error) {\n        errorFn = this.__isAsync ? (err) => { setTimeout(() => generatorOrNext.error(err)); } :\n                                   (err) => { generatorOrNext.error(err); };\n      }\n\n      if (generatorOrNext.complete) {\n        completeFn = this.__isAsync ? () => { setTimeout(() => generatorOrNext.complete()); } :\n                                      () => { generatorOrNext.complete(); };\n      }\n    } else {\n      schedulerFn = this.__isAsync ? (value: any) => { setTimeout(() => generatorOrNext(value)); } :\n                                     (value: any) => { generatorOrNext(value); };\n\n      if (error) {\n        errorFn =\n            this.__isAsync ? (err) => { setTimeout(() => error(err)); } : (err) => { error(err); };\n      }\n\n      if (complete) {\n        completeFn =\n            this.__isAsync ? () => { setTimeout(() => complete()); } : () => { complete(); };\n      }\n    }\n\n    const sink = super.subscribe(schedulerFn, errorFn, completeFn);\n\n    if (generatorOrNext instanceof Subscription) {\n      generatorOrNext.add(sink);\n    }\n\n    return sink;\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n// Import zero symbols from zone.js. This causes the zone ambient type to be\n// added to the type-checker, without emitting any runtime module load statement\nimport {} from 'zone.js';\nimport {EventEmitter} from '../event_emitter';\n\n/**\n * An injectable service for executing work inside or outside of the Angular zone.\n *\n * The most common use of this service is to optimize performance when starting a work consisting of\n * one or more asynchronous tasks that don't require UI updates or error handling to be handled by\n * Angular. Such tasks can be kicked off via {@link #runOutsideAngular} and if needed, these tasks\n * can reenter the Angular zone via {@link #run}.\n *\n * <!-- TODO: add/fix links to:\n *   - docs explaining zones and the use of zones in Angular and change-detection\n *   - link to runOutsideAngular/run (throughout this file!)\n *   -->\n *\n * @usageNotes\n * ### Example\n *\n * ```\n * import {Component, NgZone} from '@angular/core';\n * import {NgIf} from '@angular/common';\n *\n * @Component({\n *   selector: 'ng-zone-demo',\n *   template: `\n *     <h2>Demo: NgZone</h2>\n *\n *     <p>Progress: {{progress}}%</p>\n *     <p *ngIf=\"progress >= 100\">Done processing {{label}} of Angular zone!</p>\n *\n *     <button (click)=\"processWithinAngularZone()\">Process within Angular zone</button>\n *     <button (click)=\"processOutsideOfAngularZone()\">Process outside of Angular zone</button>\n *   `,\n * })\n * export class NgZoneDemo {\n *   progress: number = 0;\n *   label: string;\n *\n *   constructor(private _ngZone: NgZone) {}\n *\n *   // Loop inside the Angular zone\n *   // so the UI DOES refresh after each setTimeout cycle\n *   processWithinAngularZone() {\n *     this.label = 'inside';\n *     this.progress = 0;\n *     this._increaseProgress(() => console.log('Inside Done!'));\n *   }\n *\n *   // Loop outside of the Angular zone\n *   // so the UI DOES NOT refresh after each setTimeout cycle\n *   processOutsideOfAngularZone() {\n *     this.label = 'outside';\n *     this.progress = 0;\n *     this._ngZone.runOutsideAngular(() => {\n *       this._increaseProgress(() => {\n *         // reenter the Angular zone and display done\n *         this._ngZone.run(() => { console.log('Outside Done!'); });\n *       });\n *     });\n *   }\n *\n *   _increaseProgress(doneCallback: () => void) {\n *     this.progress += 1;\n *     console.log(`Current progress: ${this.progress}%`);\n *\n *     if (this.progress < 100) {\n *       window.setTimeout(() => this._increaseProgress(doneCallback), 10);\n *     } else {\n *       doneCallback();\n *     }\n *   }\n * }\n * ```\n *\n * @experimental\n */\nexport class NgZone {\n  readonly hasPendingMicrotasks: boolean = false;\n  readonly hasPendingMacrotasks: boolean = false;\n\n  /**\n   * Whether there are no outstanding microtasks or macrotasks.\n   */\n  readonly isStable: boolean = true;\n\n  /**\n   * Notifies when code enters Angular Zone. This gets fired first on VM Turn.\n   */\n  readonly onUnstable: EventEmitter<any> = new EventEmitter(false);\n\n  /**\n   * Notifies when there is no more microtasks enqueued in the current VM Turn.\n   * This is a hint for Angular to do change detection, which may enqueue more microtasks.\n   * For this reason this event can fire multiple times per VM Turn.\n   */\n  readonly onMicrotaskEmpty: EventEmitter<any> = new EventEmitter(false);\n\n  /**\n   * Notifies when the last `onMicrotaskEmpty` has run and there are no more microtasks, which\n   * implies we are about to relinquish VM turn.\n   * This event gets called just once.\n   */\n  readonly onStable: EventEmitter<any> = new EventEmitter(false);\n\n  /**\n   * Notifies that an error has been delivered.\n   */\n  readonly onError: EventEmitter<any> = new EventEmitter(false);\n\n  constructor({enableLongStackTrace = false}) {\n    if (typeof Zone == 'undefined') {\n      throw new Error(`In this configuration Angular requires Zone.js`);\n    }\n\n    Zone.assertZonePatched();\n    const self = this as any as NgZonePrivate;\n    self._nesting = 0;\n\n    self._outer = self._inner = Zone.current;\n\n    if ((Zone as any)['wtfZoneSpec']) {\n      self._inner = self._inner.fork((Zone as any)['wtfZoneSpec']);\n    }\n\n    if ((Zone as any)['TaskTrackingZoneSpec']) {\n      self._inner = self._inner.fork(new ((Zone as any)['TaskTrackingZoneSpec'] as any));\n    }\n\n    if (enableLongStackTrace && (Zone as any)['longStackTraceZoneSpec']) {\n      self._inner = self._inner.fork((Zone as any)['longStackTraceZoneSpec']);\n    }\n\n    forkInnerZoneWithAngularBehavior(self);\n  }\n\n  static isInAngularZone(): boolean { return Zone.current.get('isAngularZone') === true; }\n\n  static assertInAngularZone(): void {\n    if (!NgZone.isInAngularZone()) {\n      throw new Error('Expected to be in Angular Zone, but it is not!');\n    }\n  }\n\n  static assertNotInAngularZone(): void {\n    if (NgZone.isInAngularZone()) {\n      throw new Error('Expected to not be in Angular Zone, but it is!');\n    }\n  }\n\n  /**\n   * Executes the `fn` function synchronously within the Angular zone and returns value returned by\n   * the function.\n   *\n   * Running functions via `run` allows you to reenter Angular zone from a task that was executed\n   * outside of the Angular zone (typically started via {@link #runOutsideAngular}).\n   *\n   * Any future tasks or microtasks scheduled from within this function will continue executing from\n   * within the Angular zone.\n   *\n   * If a synchronous error happens it will be rethrown and not reported via `onError`.\n   */\n  run<T>(fn: (...args: any[]) => T, applyThis?: any, applyArgs?: any[]): T {\n    return (this as any as NgZonePrivate)._inner.run(fn, applyThis, applyArgs) as T;\n  }\n\n  /**\n   * Executes the `fn` function synchronously within the Angular zone as a task and returns value\n   * returned by the function.\n   *\n   * Running functions via `run` allows you to reenter Angular zone from a task that was executed\n   * outside of the Angular zone (typically started via {@link #runOutsideAngular}).\n   *\n   * Any future tasks or microtasks scheduled from within this function will continue executing from\n   * within the Angular zone.\n   *\n   * If a synchronous error happens it will be rethrown and not reported via `onError`.\n   */\n  runTask<T>(fn: (...args: any[]) => T, applyThis?: any, applyArgs?: any[], name?: string): T {\n    const zone = (this as any as NgZonePrivate)._inner;\n    const task = zone.scheduleEventTask('NgZoneEvent: ' + name, fn, EMPTY_PAYLOAD, noop, noop);\n    try {\n      return zone.runTask(task, applyThis, applyArgs) as T;\n    } finally {\n      zone.cancelTask(task);\n    }\n  }\n\n  /**\n   * Same as `run`, except that synchronous errors are caught and forwarded via `onError` and not\n   * rethrown.\n   */\n  runGuarded<T>(fn: (...args: any[]) => T, applyThis?: any, applyArgs?: any[]): T {\n    return (this as any as NgZonePrivate)._inner.runGuarded(fn, applyThis, applyArgs) as T;\n  }\n\n  /**\n   * Executes the `fn` function synchronously in Angular's parent zone and returns value returned by\n   * the function.\n   *\n   * Running functions via {@link #runOutsideAngular} allows you to escape Angular's zone and do\n   * work that\n   * doesn't trigger Angular change-detection or is subject to Angular's error handling.\n   *\n   * Any future tasks or microtasks scheduled from within this function will continue executing from\n   * outside of the Angular zone.\n   *\n   * Use {@link #run} to reenter the Angular zone and do work that updates the application model.\n   */\n  runOutsideAngular<T>(fn: (...args: any[]) => T): T {\n    return (this as any as NgZonePrivate)._outer.run(fn) as T;\n  }\n}\n\nfunction noop() {}\nconst EMPTY_PAYLOAD = {};\n\n\ninterface NgZonePrivate extends NgZone {\n  _outer: Zone;\n  _inner: Zone;\n  _nesting: number;\n\n  hasPendingMicrotasks: boolean;\n  hasPendingMacrotasks: boolean;\n  isStable: boolean;\n}\n\nfunction checkStable(zone: NgZonePrivate) {\n  if (zone._nesting == 0 && !zone.hasPendingMicrotasks && !zone.isStable) {\n    try {\n      zone._nesting++;\n      zone.onMicrotaskEmpty.emit(null);\n    } finally {\n      zone._nesting--;\n      if (!zone.hasPendingMicrotasks) {\n        try {\n          zone.runOutsideAngular(() => zone.onStable.emit(null));\n        } finally {\n          zone.isStable = true;\n        }\n      }\n    }\n  }\n}\n\nfunction forkInnerZoneWithAngularBehavior(zone: NgZonePrivate) {\n  zone._inner = zone._inner.fork({\n    name: 'angular',\n    properties: <any>{'isAngularZone': true},\n    onInvokeTask: (delegate: ZoneDelegate, current: Zone, target: Zone, task: Task, applyThis: any,\n                   applyArgs: any): any => {\n      try {\n        onEnter(zone);\n        return delegate.invokeTask(target, task, applyThis, applyArgs);\n      } finally {\n        onLeave(zone);\n      }\n    },\n\n\n    onInvoke: (delegate: ZoneDelegate, current: Zone, target: Zone, callback: Function,\n               applyThis: any, applyArgs: any[], source: string): any => {\n      try {\n        onEnter(zone);\n        return delegate.invoke(target, callback, applyThis, applyArgs, source);\n      } finally {\n        onLeave(zone);\n      }\n    },\n\n    onHasTask:\n        (delegate: ZoneDelegate, current: Zone, target: Zone, hasTaskState: HasTaskState) => {\n          delegate.hasTask(target, hasTaskState);\n          if (current === target) {\n            // We are only interested in hasTask events which originate from our zone\n            // (A child hasTask event is not interesting to us)\n            if (hasTaskState.change == 'microTask') {\n              zone.hasPendingMicrotasks = hasTaskState.microTask;\n              checkStable(zone);\n            } else if (hasTaskState.change == 'macroTask') {\n              zone.hasPendingMacrotasks = hasTaskState.macroTask;\n            }\n          }\n        },\n\n    onHandleError: (delegate: ZoneDelegate, current: Zone, target: Zone, error: any): boolean => {\n      delegate.handleError(target, error);\n      zone.runOutsideAngular(() => zone.onError.emit(error));\n      return false;\n    }\n  });\n}\n\nfunction onEnter(zone: NgZonePrivate) {\n  zone._nesting++;\n  if (zone.isStable) {\n    zone.isStable = false;\n    zone.onUnstable.emit(null);\n  }\n}\n\nfunction onLeave(zone: NgZonePrivate) {\n  zone._nesting--;\n  checkStable(zone);\n}\n\n/**\n * Provides a noop implementation of `NgZone` which does nothing. This zone requires explicit calls\n * to framework to perform rendering.\n */\nexport class NoopNgZone implements NgZone {\n  readonly hasPendingMicrotasks: boolean = false;\n  readonly hasPendingMacrotasks: boolean = false;\n  readonly isStable: boolean = true;\n  readonly onUnstable: EventEmitter<any> = new EventEmitter();\n  readonly onMicrotaskEmpty: EventEmitter<any> = new EventEmitter();\n  readonly onStable: EventEmitter<any> = new EventEmitter();\n  readonly onError: EventEmitter<any> = new EventEmitter();\n\n  run(fn: () => any): any { return fn(); }\n\n  runGuarded(fn: () => any): any { return fn(); }\n\n  runOutsideAngular(fn: () => any): any { return fn(); }\n\n  runTask<T>(fn: () => any): any { return fn(); }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injectable} from '../di';\nimport {scheduleMicroTask} from '../util';\nimport {NgZone} from '../zone/ng_zone';\n\n/**\n * Testability API.\n * `declare` keyword causes tsickle to generate externs, so these methods are\n * not renamed by Closure Compiler.\n * @experimental\n */\nexport declare interface PublicTestability {\n  isStable(): boolean;\n  whenStable(callback: Function, timeout?: number, updateCallback?: Function): void;\n  findProviders(using: any, provider: string, exactMatch: boolean): any[];\n}\n\n// Angular internal, not intended for public API.\nexport interface PendingMacrotask {\n  source: string;\n  isPeriodic: boolean;\n  delay?: number;\n  creationLocation: Error;\n  xhr?: XMLHttpRequest;\n}\n\n// Angular internal, not intended for public API.\nexport type DoneCallback = (didWork: boolean, tasks?: PendingMacrotask[]) => void;\nexport type UpdateCallback = (tasks: PendingMacrotask[]) => boolean;\n\ninterface WaitCallback {\n  // Needs to be 'any' - setTimeout returns a number according to ES6, but\n  // on NodeJS it returns a Timer.\n  timeoutId: any;\n  doneCb: DoneCallback;\n  updateCb?: UpdateCallback;\n}\n\n/**\n * The Testability service provides testing hooks that can be accessed from\n * the browser and by services such as Protractor. Each bootstrapped Angular\n * application on the page will have an instance of Testability.\n * @experimental\n */\n@Injectable()\nexport class Testability implements PublicTestability {\n  private _pendingCount: number = 0;\n  private _isZoneStable: boolean = true;\n  /**\n   * Whether any work was done since the last 'whenStable' callback. This is\n   * useful to detect if this could have potentially destabilized another\n   * component while it is stabilizing.\n   * @internal\n   */\n  private _didWork: boolean = false;\n  private _callbacks: WaitCallback[] = [];\n\n  private taskTrackingZone: any;\n\n  constructor(private _ngZone: NgZone) {\n    this._watchAngularEvents();\n    _ngZone.run(() => { this.taskTrackingZone = Zone.current.get('TaskTrackingZone'); });\n  }\n\n  private _watchAngularEvents(): void {\n    this._ngZone.onUnstable.subscribe({\n      next: () => {\n        this._didWork = true;\n        this._isZoneStable = false;\n      }\n    });\n\n    this._ngZone.runOutsideAngular(() => {\n      this._ngZone.onStable.subscribe({\n        next: () => {\n          NgZone.assertNotInAngularZone();\n          scheduleMicroTask(() => {\n            this._isZoneStable = true;\n            this._runCallbacksIfReady();\n          });\n        }\n      });\n    });\n  }\n\n  /**\n   * Increases the number of pending request\n   * @deprecated pending requests are now tracked with zones.\n   */\n  increasePendingRequestCount(): number {\n    this._pendingCount += 1;\n    this._didWork = true;\n    return this._pendingCount;\n  }\n\n  /**\n   * Decreases the number of pending request\n   * @deprecated pending requests are now tracked with zones\n   */\n  decreasePendingRequestCount(): number {\n    this._pendingCount -= 1;\n    if (this._pendingCount < 0) {\n      throw new Error('pending async requests below zero');\n    }\n    this._runCallbacksIfReady();\n    return this._pendingCount;\n  }\n\n  /**\n   * Whether an associated application is stable\n   */\n  isStable(): boolean {\n    return this._isZoneStable && this._pendingCount === 0 && !this._ngZone.hasPendingMacrotasks;\n  }\n\n  private _runCallbacksIfReady(): void {\n    if (this.isStable()) {\n      // Schedules the call backs in a new frame so that it is always async.\n      scheduleMicroTask(() => {\n        while (this._callbacks.length !== 0) {\n          let cb = this._callbacks.pop() !;\n          clearTimeout(cb.timeoutId);\n          cb.doneCb(this._didWork);\n        }\n        this._didWork = false;\n      });\n    } else {\n      // Still not stable, send updates.\n      let pending = this.getPendingTasks();\n      this._callbacks = this._callbacks.filter((cb) => {\n        if (cb.updateCb && cb.updateCb(pending)) {\n          clearTimeout(cb.timeoutId);\n          return false;\n        }\n\n        return true;\n      });\n\n      this._didWork = true;\n    }\n  }\n\n  private getPendingTasks(): PendingMacrotask[] {\n    if (!this.taskTrackingZone) {\n      return [];\n    }\n\n    return this.taskTrackingZone.macroTasks.map((t: Task) => {\n      return {\n        source: t.source,\n        isPeriodic: t.data.isPeriodic,\n        delay: t.data.delay,\n        // From TaskTrackingZone:\n        // https://github.com/angular/zone.js/blob/master/lib/zone-spec/task-tracking.ts#L40\n        creationLocation: (t as any).creationLocation as Error,\n        // Added by Zones for XHRs\n        // https://github.com/angular/zone.js/blob/master/lib/browser/browser.ts#L133\n        xhr: (t.data as any).target\n      };\n    });\n  }\n\n  private addCallback(cb: DoneCallback, timeout?: number, updateCb?: UpdateCallback) {\n    let timeoutId: any = -1;\n    if (timeout && timeout > 0) {\n      timeoutId = setTimeout(() => {\n        this._callbacks = this._callbacks.filter((cb) => cb.timeoutId !== timeoutId);\n        cb(this._didWork, this.getPendingTasks());\n      }, timeout);\n    }\n    this._callbacks.push(<WaitCallback>{doneCb: cb, timeoutId: timeoutId, updateCb: updateCb});\n  }\n\n  /**\n   * Wait for the application to be stable with a timeout. If the timeout is reached before that\n   * happens, the callback receives a list of the macro tasks that were pending, otherwise null.\n   *\n   * @param doneCb The callback to invoke when Angular is stable or the timeout expires\n   *    whichever comes first.\n   * @param timeout Optional. The maximum time to wait for Angular to become stable. If not\n   *    specified, whenStable() will wait forever.\n   * @param updateCb Optional. If specified, this callback will be invoked whenever the set of\n   *    pending macrotasks changes. If this callback returns true doneCb will not be invoked\n   *    and no further updates will be issued.\n   */\n  whenStable(doneCb: Function, timeout?: number, updateCb?: Function): void {\n    if (updateCb && !this.taskTrackingZone) {\n      throw new Error(\n          'Task tracking zone is required when passing an update callback to ' +\n          'whenStable(). Is \"zone.js/dist/task-tracking.js\" loaded?');\n    }\n    // These arguments are 'Function' above to keep the public API simple.\n    this.addCallback(doneCb as DoneCallback, timeout, updateCb as UpdateCallback);\n    this._runCallbacksIfReady();\n  }\n\n  /**\n   * Get the number of pending requests\n   * @deprecated pending requests are now tracked with zones\n   */\n  getPendingRequestCount(): number { return this._pendingCount; }\n\n  /**\n   * Find providers by name\n   * @param using The root element to search from\n   * @param provider The name of binding variable\n   * @param exactMatch Whether using exactMatch\n   */\n  findProviders(using: any, provider: string, exactMatch: boolean): any[] {\n    // TODO(juliemr): implement.\n    return [];\n  }\n}\n\n/**\n * A global registry of {@link Testability} instances for specific elements.\n * @experimental\n */\n@Injectable()\nexport class TestabilityRegistry {\n  /** @internal */\n  _applications = new Map<any, Testability>();\n\n  constructor() { _testabilityGetter.addToWindow(this); }\n\n  /**\n   * Registers an application with a testability hook so that it can be tracked\n   * @param token token of application, root element\n   * @param testability Testability hook\n   */\n  registerApplication(token: any, testability: Testability) {\n    this._applications.set(token, testability);\n  }\n\n  /**\n   * Unregisters an application.\n   * @param token token of application, root element\n   */\n  unregisterApplication(token: any) { this._applications.delete(token); }\n\n  /**\n   * Unregisters all applications\n   */\n  unregisterAllApplications() { this._applications.clear(); }\n\n  /**\n   * Get a testability hook associated with the application\n   * @param elem root element\n   */\n  getTestability(elem: any): Testability|null { return this._applications.get(elem) || null; }\n\n  /**\n   * Get all registered testabilities\n   */\n  getAllTestabilities(): Testability[] { return Array.from(this._applications.values()); }\n\n  /**\n   * Get all registered applications(root elements)\n   */\n  getAllRootElements(): any[] { return Array.from(this._applications.keys()); }\n\n  /**\n   * Find testability of a node in the Tree\n   * @param elem node\n   * @param findInAncestors whether finding testability in ancestors if testability was not found in\n   * current node\n   */\n  findTestabilityInTree(elem: Node, findInAncestors: boolean = true): Testability|null {\n    return _testabilityGetter.findTestabilityInTree(this, elem, findInAncestors);\n  }\n}\n\n/**\n * Adapter interface for retrieving the `Testability` service associated for a\n * particular context.\n *\n * @experimental Testability apis are primarily intended to be used by e2e test tool vendors like\n * the Protractor team.\n */\nexport interface GetTestability {\n  addToWindow(registry: TestabilityRegistry): void;\n  findTestabilityInTree(registry: TestabilityRegistry, elem: any, findInAncestors: boolean):\n      Testability|null;\n}\n\nclass _NoopGetTestability implements GetTestability {\n  addToWindow(registry: TestabilityRegistry): void {}\n  findTestabilityInTree(registry: TestabilityRegistry, elem: any, findInAncestors: boolean):\n      Testability|null {\n    return null;\n  }\n}\n\n/**\n * Set the {@link GetTestability} implementation used by the Angular testing framework.\n * @experimental\n */\nexport function setTestabilityGetter(getter: GetTestability): void {\n  _testabilityGetter = getter;\n}\n\nlet _testabilityGetter: GetTestability = new _NoopGetTestability();\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Observable, Observer, Subscription, merge} from 'rxjs';\nimport {share} from 'rxjs/operators';\n\nimport {ErrorHandler} from '../src/error_handler';\nimport {scheduleMicroTask, stringify} from '../src/util';\nimport {isPromise} from '../src/util/lang';\n\nimport {ApplicationInitStatus} from './application_init';\nimport {APP_BOOTSTRAP_LISTENER, PLATFORM_INITIALIZER} from './application_tokens';\nimport {Console} from './console';\nimport {Injectable, InjectionToken, Injector, StaticProvider} from './di';\nimport {CompilerFactory, CompilerOptions} from './linker/compiler';\nimport {ComponentFactory, ComponentRef} from './linker/component_factory';\nimport {ComponentFactoryBoundToModule, ComponentFactoryResolver} from './linker/component_factory_resolver';\nimport {InternalNgModuleRef, NgModuleFactory, NgModuleRef} from './linker/ng_module_factory';\nimport {InternalViewRef, ViewRef} from './linker/view_ref';\nimport {WtfScopeFn, wtfCreateScope, wtfLeave} from './profile/profile';\nimport {Testability, TestabilityRegistry} from './testability/testability';\nimport {Type} from './type';\nimport {NgZone, NoopNgZone} from './zone/ng_zone';\n\nlet _devMode: boolean = true;\nlet _runModeLocked: boolean = false;\nlet _platform: PlatformRef;\n\nexport const ALLOW_MULTIPLE_PLATFORMS = new InjectionToken<boolean>('AllowMultipleToken');\n\n/**\n * Disable Angular's development mode, which turns off assertions and other\n * checks within the framework.\n *\n * One important assertion this disables verifies that a change detection pass\n * does not result in additional changes to any bindings (also known as\n * unidirectional data flow).\n *\n *\n */\nexport function enableProdMode(): void {\n  if (_runModeLocked) {\n    throw new Error('Cannot enable prod mode after platform setup.');\n  }\n  _devMode = false;\n}\n\n/**\n * Returns whether Angular is in development mode. After called once,\n * the value is locked and won't change any more.\n *\n * By default, this is true, unless a user calls `enableProdMode` before calling this.\n *\n * @experimental APIs related to application bootstrap are currently under review.\n */\nexport function isDevMode(): boolean {\n  _runModeLocked = true;\n  return _devMode;\n}\n\n/**\n * A token for third-party components that can register themselves with NgProbe.\n *\n * @experimental\n */\nexport class NgProbeToken {\n  constructor(public name: string, public token: any) {}\n}\n\n/**\n * Creates a platform.\n * Platforms have to be eagerly created via this function.\n *\n * @experimental APIs related to application bootstrap are currently under review.\n */\nexport function createPlatform(injector: Injector): PlatformRef {\n  if (_platform && !_platform.destroyed &&\n      !_platform.injector.get(ALLOW_MULTIPLE_PLATFORMS, false)) {\n    throw new Error(\n        'There can be only one platform. Destroy the previous one to create a new one.');\n  }\n  _platform = injector.get(PlatformRef);\n  const inits = injector.get(PLATFORM_INITIALIZER, null);\n  if (inits) inits.forEach((init: any) => init());\n  return _platform;\n}\n\n/**\n * Creates a factory for a platform\n *\n * @experimental APIs related to application bootstrap are currently under review.\n */\nexport function createPlatformFactory(\n    parentPlatformFactory: ((extraProviders?: StaticProvider[]) => PlatformRef) | null,\n    name: string, providers: StaticProvider[] = []): (extraProviders?: StaticProvider[]) =>\n    PlatformRef {\n  const desc = `Platform: ${name}`;\n  const marker = new InjectionToken(desc);\n  return (extraProviders: StaticProvider[] = []) => {\n    let platform = getPlatform();\n    if (!platform || platform.injector.get(ALLOW_MULTIPLE_PLATFORMS, false)) {\n      if (parentPlatformFactory) {\n        parentPlatformFactory(\n            providers.concat(extraProviders).concat({provide: marker, useValue: true}));\n      } else {\n        const injectedProviders: StaticProvider[] =\n            providers.concat(extraProviders).concat({provide: marker, useValue: true});\n        createPlatform(Injector.create({providers: injectedProviders, name: desc}));\n      }\n    }\n    return assertPlatform(marker);\n  };\n}\n\n/**\n * Checks that there currently is a platform which contains the given token as a provider.\n *\n * @experimental APIs related to application bootstrap are currently under review.\n */\nexport function assertPlatform(requiredToken: any): PlatformRef {\n  const platform = getPlatform();\n\n  if (!platform) {\n    throw new Error('No platform exists!');\n  }\n\n  if (!platform.injector.get(requiredToken, null)) {\n    throw new Error(\n        'A platform with a different configuration has been created. Please destroy it first.');\n  }\n\n  return platform;\n}\n\n/**\n * Destroy the existing platform.\n *\n * @experimental APIs related to application bootstrap are currently under review.\n */\nexport function destroyPlatform(): void {\n  if (_platform && !_platform.destroyed) {\n    _platform.destroy();\n  }\n}\n\n/**\n * Returns the current platform.\n *\n * @experimental APIs related to application bootstrap are currently under review.\n */\nexport function getPlatform(): PlatformRef|null {\n  return _platform && !_platform.destroyed ? _platform : null;\n}\n\n/**\n * Provides additional options to the bootstraping process.\n *\n *\n */\nexport interface BootstrapOptions {\n  /**\n   * Optionally specify which `NgZone` should be used.\n   *\n   * - Provide your own `NgZone` instance.\n   * - `zone.js` - Use default `NgZone` which requires `Zone.js`.\n   * - `noop` - Use `NoopNgZone` which does nothing.\n   */\n  ngZone?: NgZone|'zone.js'|'noop';\n}\n\n/**\n * The Angular platform is the entry point for Angular on a web page. Each page\n * has exactly one platform, and services (such as reflection) which are common\n * to every Angular application running on the page are bound in its scope.\n *\n * A page's platform is initialized implicitly when a platform is created via a platform factory\n * (e.g. {@link platformBrowser}), or explicitly by calling the {@link createPlatform} function.\n */\n@Injectable()\nexport class PlatformRef {\n  private _modules: NgModuleRef<any>[] = [];\n  private _destroyListeners: Function[] = [];\n  private _destroyed: boolean = false;\n\n  /** @internal */\n  constructor(private _injector: Injector) {}\n\n  /**\n   * Creates an instance of an `@NgModule` for the given platform\n   * for offline compilation.\n   *\n   * @usageNotes\n   * ### Simple Example\n   *\n   * ```typescript\n   * my_module.ts:\n   *\n   * @NgModule({\n   *   imports: [BrowserModule]\n   * })\n   * class MyModule {}\n   *\n   * main.ts:\n   * import {MyModuleNgFactory} from './my_module.ngfactory';\n   * import {platformBrowser} from '@angular/platform-browser';\n   *\n   * let moduleRef = platformBrowser().bootstrapModuleFactory(MyModuleNgFactory);\n   * ```\n   *\n   * @experimental APIs related to application bootstrap are currently under review.\n   */\n  bootstrapModuleFactory<M>(moduleFactory: NgModuleFactory<M>, options?: BootstrapOptions):\n      Promise<NgModuleRef<M>> {\n    // Note: We need to create the NgZone _before_ we instantiate the module,\n    // as instantiating the module creates some providers eagerly.\n    // So we create a mini parent injector that just contains the new NgZone and\n    // pass that as parent to the NgModuleFactory.\n    const ngZoneOption = options ? options.ngZone : undefined;\n    const ngZone = getNgZone(ngZoneOption);\n    const providers: StaticProvider[] = [{provide: NgZone, useValue: ngZone}];\n    // Attention: Don't use ApplicationRef.run here,\n    // as we want to be sure that all possible constructor calls are inside `ngZone.run`!\n    return ngZone.run(() => {\n      const ngZoneInjector = Injector.create(\n          {providers: providers, parent: this.injector, name: moduleFactory.moduleType.name});\n      const moduleRef = <InternalNgModuleRef<M>>moduleFactory.create(ngZoneInjector);\n      const exceptionHandler: ErrorHandler = moduleRef.injector.get(ErrorHandler, null);\n      if (!exceptionHandler) {\n        throw new Error('No ErrorHandler. Is platform module (BrowserModule) included?');\n      }\n      moduleRef.onDestroy(() => remove(this._modules, moduleRef));\n      ngZone !.runOutsideAngular(\n          () => ngZone !.onError.subscribe(\n              {next: (error: any) => { exceptionHandler.handleError(error); }}));\n      return _callAndReportToErrorHandler(exceptionHandler, ngZone !, () => {\n        const initStatus: ApplicationInitStatus = moduleRef.injector.get(ApplicationInitStatus);\n        initStatus.runInitializers();\n        return initStatus.donePromise.then(() => {\n          this._moduleDoBootstrap(moduleRef);\n          return moduleRef;\n        });\n      });\n    });\n  }\n\n  /**\n   * Creates an instance of an `@NgModule` for a given platform using the given runtime compiler.\n   *\n   * @usageNotes\n   * ### Simple Example\n   *\n   * ```typescript\n   * @NgModule({\n   *   imports: [BrowserModule]\n   * })\n   * class MyModule {}\n   *\n   * let moduleRef = platformBrowser().bootstrapModule(MyModule);\n   * ```\n   *\n   */\n  bootstrapModule<M>(\n      moduleType: Type<M>, compilerOptions: (CompilerOptions&BootstrapOptions)|\n      Array<CompilerOptions&BootstrapOptions> = []): Promise<NgModuleRef<M>> {\n    const compilerFactory: CompilerFactory = this.injector.get(CompilerFactory);\n    const options = optionsReducer({}, compilerOptions);\n    const compiler = compilerFactory.createCompiler([options]);\n\n    return compiler.compileModuleAsync(moduleType)\n        .then((moduleFactory) => this.bootstrapModuleFactory(moduleFactory, options));\n  }\n\n  private _moduleDoBootstrap(moduleRef: InternalNgModuleRef<any>): void {\n    const appRef = moduleRef.injector.get(ApplicationRef) as ApplicationRef;\n    if (moduleRef._bootstrapComponents.length > 0) {\n      moduleRef._bootstrapComponents.forEach(f => appRef.bootstrap(f));\n    } else if (moduleRef.instance.ngDoBootstrap) {\n      moduleRef.instance.ngDoBootstrap(appRef);\n    } else {\n      throw new Error(\n          `The module ${stringify(moduleRef.instance.constructor)} was bootstrapped, but it does not declare \"@NgModule.bootstrap\" components nor a \"ngDoBootstrap\" method. ` +\n          `Please define one of these.`);\n    }\n    this._modules.push(moduleRef);\n  }\n\n  /**\n   * Register a listener to be called when the platform is disposed.\n   */\n  onDestroy(callback: () => void): void { this._destroyListeners.push(callback); }\n\n  /**\n   * Retrieve the platform {@link Injector}, which is the parent injector for\n   * every Angular application on the page and provides singleton providers.\n   */\n  get injector(): Injector { return this._injector; }\n\n  /**\n   * Destroy the Angular platform and all Angular applications on the page.\n   */\n  destroy() {\n    if (this._destroyed) {\n      throw new Error('The platform has already been destroyed!');\n    }\n    this._modules.slice().forEach(module => module.destroy());\n    this._destroyListeners.forEach(listener => listener());\n    this._destroyed = true;\n  }\n\n  get destroyed() { return this._destroyed; }\n}\n\nfunction getNgZone(ngZoneOption?: NgZone | 'zone.js' | 'noop'): NgZone {\n  let ngZone: NgZone;\n\n  if (ngZoneOption === 'noop') {\n    ngZone = new NoopNgZone();\n  } else {\n    ngZone = (ngZoneOption === 'zone.js' ? undefined : ngZoneOption) ||\n        new NgZone({enableLongStackTrace: isDevMode()});\n  }\n  return ngZone;\n}\n\nfunction _callAndReportToErrorHandler(\n    errorHandler: ErrorHandler, ngZone: NgZone, callback: () => any): any {\n  try {\n    const result = callback();\n    if (isPromise(result)) {\n      return result.catch((e: any) => {\n        ngZone.runOutsideAngular(() => errorHandler.handleError(e));\n        // rethrow as the exception handler might not do it\n        throw e;\n      });\n    }\n\n    return result;\n  } catch (e) {\n    ngZone.runOutsideAngular(() => errorHandler.handleError(e));\n    // rethrow as the exception handler might not do it\n    throw e;\n  }\n}\n\nfunction optionsReducer<T extends Object>(dst: any, objs: T | T[]): T {\n  if (Array.isArray(objs)) {\n    dst = objs.reduce(optionsReducer, dst);\n  } else {\n    dst = {...dst, ...(objs as any)};\n  }\n  return dst;\n}\n\n/**\n * A reference to an Angular application running on a page.\n */\n@Injectable()\nexport class ApplicationRef {\n  /** @internal */\n  static _tickScope: WtfScopeFn = wtfCreateScope('ApplicationRef#tick()');\n  private _bootstrapListeners: ((compRef: ComponentRef<any>) => void)[] = [];\n  private _views: InternalViewRef[] = [];\n  private _runningTick: boolean = false;\n  private _enforceNoNewChanges: boolean = false;\n  private _stable = true;\n\n  /**\n   * Get a list of component types registered to this application.\n   * This list is populated even before the component is created.\n   */\n  public readonly componentTypes: Type<any>[] = [];\n\n  /**\n   * Get a list of components registered to this application.\n   */\n  public readonly components: ComponentRef<any>[] = [];\n\n  /**\n   * Returns an Observable that indicates when the application is stable or unstable.\n   */\n  public readonly isStable: Observable<boolean>;\n\n  /** @internal */\n  constructor(\n      private _zone: NgZone, private _console: Console, private _injector: Injector,\n      private _exceptionHandler: ErrorHandler,\n      private _componentFactoryResolver: ComponentFactoryResolver,\n      private _initStatus: ApplicationInitStatus) {\n    this._enforceNoNewChanges = isDevMode();\n\n    this._zone.onMicrotaskEmpty.subscribe(\n        {next: () => { this._zone.run(() => { this.tick(); }); }});\n\n    const isCurrentlyStable = new Observable<boolean>((observer: Observer<boolean>) => {\n      this._stable = this._zone.isStable && !this._zone.hasPendingMacrotasks &&\n          !this._zone.hasPendingMicrotasks;\n      this._zone.runOutsideAngular(() => {\n        observer.next(this._stable);\n        observer.complete();\n      });\n    });\n\n    const isStable = new Observable<boolean>((observer: Observer<boolean>) => {\n      // Create the subscription to onStable outside the Angular Zone so that\n      // the callback is run outside the Angular Zone.\n      let stableSub: Subscription;\n      this._zone.runOutsideAngular(() => {\n        stableSub = this._zone.onStable.subscribe(() => {\n          NgZone.assertNotInAngularZone();\n\n          // Check whether there are no pending macro/micro tasks in the next tick\n          // to allow for NgZone to update the state.\n          scheduleMicroTask(() => {\n            if (!this._stable && !this._zone.hasPendingMacrotasks &&\n                !this._zone.hasPendingMicrotasks) {\n              this._stable = true;\n              observer.next(true);\n            }\n          });\n        });\n      });\n\n      const unstableSub: Subscription = this._zone.onUnstable.subscribe(() => {\n        NgZone.assertInAngularZone();\n        if (this._stable) {\n          this._stable = false;\n          this._zone.runOutsideAngular(() => { observer.next(false); });\n        }\n      });\n\n      return () => {\n        stableSub.unsubscribe();\n        unstableSub.unsubscribe();\n      };\n    });\n\n    (this as{isStable: Observable<boolean>}).isStable =\n        merge(isCurrentlyStable, isStable.pipe(share()));\n  }\n\n  /**\n   * Bootstrap a new component at the root level of the application.\n   *\n   * @usageNotes\n   * ### Bootstrap process\n   *\n   * When bootstrapping a new root component into an application, Angular mounts the\n   * specified application component onto DOM elements identified by the componentType's\n   * selector and kicks off automatic change detection to finish initializing the component.\n   *\n   * Optionally, a component can be mounted onto a DOM element that does not match the\n   * componentType's selector.\n   *\n   * ### Example\n   * {@example core/ts/platform/platform.ts region='longform'}\n   */\n  bootstrap<C>(componentOrFactory: ComponentFactory<C>|Type<C>, rootSelectorOrNode?: string|any):\n      ComponentRef<C> {\n    if (!this._initStatus.done) {\n      throw new Error(\n          'Cannot bootstrap as there are still asynchronous initializers running. Bootstrap components in the `ngDoBootstrap` method of the root module.');\n    }\n    let componentFactory: ComponentFactory<C>;\n    if (componentOrFactory instanceof ComponentFactory) {\n      componentFactory = componentOrFactory;\n    } else {\n      componentFactory =\n          this._componentFactoryResolver.resolveComponentFactory(componentOrFactory) !;\n    }\n    this.componentTypes.push(componentFactory.componentType);\n\n    // Create a factory associated with the current module if it's not bound to some other\n    const ngModule = componentFactory instanceof ComponentFactoryBoundToModule ?\n        null :\n        this._injector.get(NgModuleRef);\n    const selectorOrNode = rootSelectorOrNode || componentFactory.selector;\n    const compRef = componentFactory.create(Injector.NULL, [], selectorOrNode, ngModule);\n\n    compRef.onDestroy(() => { this._unloadComponent(compRef); });\n    const testability = compRef.injector.get(Testability, null);\n    if (testability) {\n      compRef.injector.get(TestabilityRegistry)\n          .registerApplication(compRef.location.nativeElement, testability);\n    }\n\n    this._loadComponent(compRef);\n    if (isDevMode()) {\n      this._console.log(\n          `Angular is running in the development mode. Call enableProdMode() to enable the production mode.`);\n    }\n    return compRef;\n  }\n\n  /**\n   * Invoke this method to explicitly process change detection and its side-effects.\n   *\n   * In development mode, `tick()` also performs a second change detection cycle to ensure that no\n   * further changes are detected. If additional changes are picked up during this second cycle,\n   * bindings in the app have side-effects that cannot be resolved in a single change detection\n   * pass.\n   * In this case, Angular throws an error, since an Angular application can only have one change\n   * detection pass during which all change detection must complete.\n   */\n  tick(): void {\n    if (this._runningTick) {\n      throw new Error('ApplicationRef.tick is called recursively');\n    }\n\n    const scope = ApplicationRef._tickScope();\n    try {\n      this._runningTick = true;\n      this._views.forEach((view) => view.detectChanges());\n      if (this._enforceNoNewChanges) {\n        this._views.forEach((view) => view.checkNoChanges());\n      }\n    } catch (e) {\n      // Attention: Don't rethrow as it could cancel subscriptions to Observables!\n      this._zone.runOutsideAngular(() => this._exceptionHandler.handleError(e));\n    } finally {\n      this._runningTick = false;\n      wtfLeave(scope);\n    }\n  }\n\n  /**\n   * Attaches a view so that it will be dirty checked.\n   * The view will be automatically detached when it is destroyed.\n   * This will throw if the view is already attached to a ViewContainer.\n   */\n  attachView(viewRef: ViewRef): void {\n    const view = (viewRef as InternalViewRef);\n    this._views.push(view);\n    view.attachToAppRef(this);\n  }\n\n  /**\n   * Detaches a view from dirty checking again.\n   */\n  detachView(viewRef: ViewRef): void {\n    const view = (viewRef as InternalViewRef);\n    remove(this._views, view);\n    view.detachFromAppRef();\n  }\n\n  private _loadComponent(componentRef: ComponentRef<any>): void {\n    this.attachView(componentRef.hostView);\n    this.tick();\n    this.components.push(componentRef);\n    // Get the listeners lazily to prevent DI cycles.\n    const listeners =\n        this._injector.get(APP_BOOTSTRAP_LISTENER, []).concat(this._bootstrapListeners);\n    listeners.forEach((listener) => listener(componentRef));\n  }\n\n  private _unloadComponent(componentRef: ComponentRef<any>): void {\n    this.detachView(componentRef.hostView);\n    remove(this.components, componentRef);\n  }\n\n  /** @internal */\n  ngOnDestroy() {\n    // TODO(alxhub): Dispose of the NgZone.\n    this._views.slice().forEach((view) => view.destroy());\n  }\n\n  /**\n   * Returns the number of attached views.\n   */\n  get viewCount() { return this._views.length; }\n}\n\nfunction remove<T>(list: T[], el: T): void {\n  const index = list.indexOf(el);\n  if (index > -1) {\n    list.splice(index, 1);\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n// Public API for Zone\nexport {NgZone} from './zone/ng_zone';\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {InjectionToken, Injector} from '../di';\nimport {ViewEncapsulation} from '../metadata/view';\n\n/**\n * @deprecated Use `RendererType2` (and `Renderer2`) instead.\n */\nexport class RenderComponentType {\n  constructor(\n      public id: string, public templateUrl: string, public slotCount: number,\n      public encapsulation: ViewEncapsulation, public styles: Array<string|any[]>,\n      public animations: any) {}\n}\n\n/**\n * @deprecated Debug info is handeled internally in the view engine now.\n */\nexport abstract class RenderDebugInfo {\n  abstract get injector(): Injector;\n  abstract get component(): any;\n  abstract get providerTokens(): any[];\n  abstract get references(): {[key: string]: any};\n  abstract get context(): any;\n  abstract get source(): string;\n}\n\n/**\n * @deprecated Use the `Renderer2` instead.\n */\nexport interface DirectRenderer {\n  remove(node: any): void;\n  appendChild(node: any, parent: any): void;\n  insertBefore(node: any, refNode: any): void;\n  nextSibling(node: any): any;\n  parentElement(node: any): any;\n}\n\n/**\n * @deprecated Use the `Renderer2` instead.\n */\nexport abstract class Renderer {\n  abstract selectRootElement(selectorOrNode: string|any, debugInfo?: RenderDebugInfo): any;\n\n  abstract createElement(parentElement: any, name: string, debugInfo?: RenderDebugInfo): any;\n\n  abstract createViewRoot(hostElement: any): any;\n\n  abstract createTemplateAnchor(parentElement: any, debugInfo?: RenderDebugInfo): any;\n\n  abstract createText(parentElement: any, value: string, debugInfo?: RenderDebugInfo): any;\n\n  abstract projectNodes(parentElement: any, nodes: any[]): void;\n\n  abstract attachViewAfter(node: any, viewRootNodes: any[]): void;\n\n  abstract detachView(viewRootNodes: any[]): void;\n\n  abstract destroyView(hostElement: any, viewAllNodes: any[]): void;\n\n  abstract listen(renderElement: any, name: string, callback: Function): Function;\n\n  abstract listenGlobal(target: string, name: string, callback: Function): Function;\n\n  abstract setElementProperty(renderElement: any, propertyName: string, propertyValue: any): void;\n\n  abstract setElementAttribute(renderElement: any, attributeName: string, attributeValue: string):\n      void;\n\n  /**\n   * Used only in debug mode to serialize property changes to dom nodes as attributes.\n   */\n  abstract setBindingDebugInfo(renderElement: any, propertyName: string, propertyValue: string):\n      void;\n\n  abstract setElementClass(renderElement: any, className: string, isAdd: boolean): void;\n\n  abstract setElementStyle(renderElement: any, styleName: string, styleValue: string): void;\n\n  abstract invokeElementMethod(renderElement: any, methodName: string, args?: any[]): void;\n\n  abstract setText(renderNode: any, text: string): void;\n\n  abstract animate(\n      element: any, startingStyles: any, keyframes: any[], duration: number, delay: number,\n      easing: string, previousPlayers?: any[]): any;\n}\n\nexport const Renderer2Interceptor = new InjectionToken<Renderer2[]>('Renderer2Interceptor');\n\n/**\n * Injectable service that provides a low-level interface for modifying the UI.\n *\n * Use this service to bypass Angular's templating and make custom UI changes that can't be\n * expressed declaratively. For example if you need to set a property or an attribute whose name is\n * not statically known, use {@link Renderer#setElementProperty setElementProperty} or\n * {@link Renderer#setElementAttribute setElementAttribute} respectively.\n *\n * If you are implementing a custom renderer, you must implement this interface.\n *\n * The default Renderer implementation is `DomRenderer`. Also available is `WebWorkerRenderer`.\n *\n * @deprecated Use `RendererFactory2` instead.\n */\nexport abstract class RootRenderer {\n  abstract renderComponent(componentType: RenderComponentType): Renderer;\n}\n\n/**\n * @experimental\n */\nexport interface RendererType2 {\n  id: string;\n  encapsulation: ViewEncapsulation;\n  styles: (string|any[])[];\n  data: {[kind: string]: any};\n}\n\n/**\n * @experimental\n */\nexport abstract class RendererFactory2 {\n  abstract createRenderer(hostElement: any, type: RendererType2|null): Renderer2;\n  abstract begin?(): void;\n  abstract end?(): void;\n  abstract whenRenderingDone?(): Promise<any>;\n}\n\n/**\n * @experimental\n */\nexport enum RendererStyleFlags2 {\n  Important = 1 << 0,\n  DashCase = 1 << 1\n}\n\n/**\n * @experimental\n */\nexport abstract class Renderer2 {\n  /**\n   * This field can be used to store arbitrary data on this renderer instance.\n   * This is useful for renderers that delegate to other renderers.\n   */\n  abstract get data(): {[key: string]: any};\n\n  abstract destroy(): void;\n  abstract createElement(name: string, namespace?: string|null): any;\n  abstract createComment(value: string): any;\n  abstract createText(value: string): any;\n  /**\n   * This property is allowed to be null / undefined,\n   * in which case the view engine won't call it.\n   * This is used as a performance optimization for production mode.\n   */\n  destroyNode: ((node: any) => void)|null;\n  abstract appendChild(parent: any, newChild: any): void;\n  abstract insertBefore(parent: any, newChild: any, refChild: any): void;\n  abstract removeChild(parent: any, oldChild: any): void;\n  abstract selectRootElement(selectorOrNode: string|any): any;\n  /**\n   * Attention: On WebWorkers, this will always return a value,\n   * as we are asking for a result synchronously. I.e.\n   * the caller can't rely on checking whether this is null or not.\n   */\n  abstract parentNode(node: any): any;\n  /**\n   * Attention: On WebWorkers, this will always return a value,\n   * as we are asking for a result synchronously. I.e.\n   * the caller can't rely on checking whether this is null or not.\n   */\n  abstract nextSibling(node: any): any;\n  abstract setAttribute(el: any, name: string, value: string, namespace?: string|null): void;\n  abstract removeAttribute(el: any, name: string, namespace?: string|null): void;\n  abstract addClass(el: any, name: string): void;\n  abstract removeClass(el: any, name: string): void;\n  abstract setStyle(el: any, style: string, value: any, flags?: RendererStyleFlags2): void;\n  abstract removeStyle(el: any, style: string, flags?: RendererStyleFlags2): void;\n  abstract setProperty(el: any, name: string, value: any): void;\n  abstract setValue(node: any, value: string): void;\n  abstract listen(\n      target: 'window'|'document'|'body'|any, eventName: string,\n      callback: (event: any) => boolean | void): () => void;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n// Public API for render\nexport {RenderComponentType, Renderer, Renderer2, RendererFactory2, RendererStyleFlags2, RendererType2, RootRenderer} from './render/api';\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * A wrapper around a native element inside of a View.\n *\n * An `ElementRef` is backed by a render-specific element. In the browser, this is usually a DOM\n * element.\n *\n * @security Permitting direct access to the DOM can make your application more vulnerable to\n * XSS attacks. Carefully review any use of `ElementRef` in your code. For more detail, see the\n * [Security Guide](http://g.co/ng/security).\n *\n *\n */\n// Note: We don't expose things like `Injector`, `ViewContainer`, ... here,\n// i.e. users have to ask for what they need. With that, we can build better analysis tools\n// and could do better codegen in the future.\nexport class ElementRef<T = any> {\n  /**\n   * The underlying native element or `null` if direct access to native elements is not supported\n   * (e.g. when the application runs in a web worker).\n   *\n   * <div class=\"callout is-critical\">\n   *   <header>Use with caution</header>\n   *   <p>\n   *    Use this API as the last resort when direct access to DOM is needed. Use templating and\n   *    data-binding provided by Angular instead. Alternatively you can take a look at {@link\n   * Renderer2}\n   *    which provides API that can safely be used even when direct access to native elements is not\n   *    supported.\n   *   </p>\n   *   <p>\n   *    Relying on direct DOM access creates tight coupling between your application and rendering\n   *    layers which will make it impossible to separate the two and deploy your application into a\n   *    web worker.\n   *   </p>\n   * </div>\n   *\n   */\n  public nativeElement: T;\n\n  constructor(nativeElement: T) { this.nativeElement = nativeElement; }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {NgModuleFactory} from './ng_module_factory';\n\n/**\n * Used to load ng module factories.\n *\n */\nexport abstract class NgModuleFactoryLoader {\n  abstract load(path: string): Promise<NgModuleFactory<any>>;\n}\n\nlet moduleFactories = new Map<string, NgModuleFactory<any>>();\n\n/**\n * Registers a loaded module. Should only be called from generated NgModuleFactory code.\n * @experimental\n */\nexport function registerModuleFactory(id: string, factory: NgModuleFactory<any>) {\n  const existing = moduleFactories.get(id);\n  if (existing) {\n    throw new Error(`Duplicate module registered for ${id\n                    } - ${existing.moduleType.name} vs ${factory.moduleType.name}`);\n  }\n  moduleFactories.set(id, factory);\n}\n\nexport function clearModulesForTest() {\n  moduleFactories = new Map<string, NgModuleFactory<any>>();\n}\n\n/**\n * Returns the NgModuleFactory with the given id, if it exists and has been loaded.\n * Factories for modules that do not specify an `id` cannot be retrieved. Throws if the module\n * cannot be found.\n * @experimental\n */\nexport function getModuleFactory(id: string): NgModuleFactory<any> {\n  const factory = moduleFactories.get(id);\n  if (!factory) throw new Error(`No module with ID ${id} loaded`);\n  return factory;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Observable} from 'rxjs';\n\nimport {EventEmitter} from '../event_emitter';\nimport {getSymbolIterator} from '../util';\n\n\n/**\n * An unmodifiable list of items that Angular keeps up to date when the state\n * of the application changes.\n *\n * The type of object that {@link ViewChildren}, {@link ContentChildren}, and {@link QueryList}\n * provide.\n *\n * Implements an iterable interface, therefore it can be used in both ES6\n * javascript `for (var i of items)` loops as well as in Angular templates with\n * `*ngFor=\"let i of myList\"`.\n *\n * Changes can be observed by subscribing to the changes `Observable`.\n *\n * NOTE: In the future this class will implement an `Observable` interface.\n *\n * @usageNotes\n * ### Example\n * ```typescript\n * @Component({...})\n * class Container {\n *   @ViewChildren(Item) items:QueryList<Item>;\n * }\n * ```\n */\nexport class QueryList<T>/* implements Iterable<T> */ {\n  public readonly dirty = true;\n  private _results: Array<T> = [];\n  public readonly changes: Observable<any> = new EventEmitter();\n\n  readonly length: number = 0;\n  readonly first: T;\n  readonly last: T;\n\n  /**\n   * See\n   * [Array.map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)\n   */\n  map<U>(fn: (item: T, index: number, array: T[]) => U): U[] { return this._results.map(fn); }\n\n  /**\n   * See\n   * [Array.filter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter)\n   */\n  filter(fn: (item: T, index: number, array: T[]) => boolean): T[] {\n    return this._results.filter(fn);\n  }\n\n  /**\n   * See\n   * [Array.find](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find)\n   */\n  find(fn: (item: T, index: number, array: T[]) => boolean): T|undefined {\n    return this._results.find(fn);\n  }\n\n  /**\n   * See\n   * [Array.reduce](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce)\n   */\n  reduce<U>(fn: (prevValue: U, curValue: T, curIndex: number, array: T[]) => U, init: U): U {\n    return this._results.reduce(fn, init);\n  }\n\n  /**\n   * See\n   * [Array.forEach](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach)\n   */\n  forEach(fn: (item: T, index: number, array: T[]) => void): void { this._results.forEach(fn); }\n\n  /**\n   * See\n   * [Array.some](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some)\n   */\n  some(fn: (value: T, index: number, array: T[]) => boolean): boolean {\n    return this._results.some(fn);\n  }\n\n  toArray(): T[] { return this._results.slice(); }\n\n  [getSymbolIterator()](): Iterator<T> { return (this._results as any)[getSymbolIterator()](); }\n\n  toString(): string { return this._results.toString(); }\n\n  reset(res: Array<T|any[]>): void {\n    this._results = flatten(res);\n    (this as{dirty: boolean}).dirty = false;\n    (this as{length: number}).length = this._results.length;\n    (this as{last: T}).last = this._results[this.length - 1];\n    (this as{first: T}).first = this._results[0];\n  }\n\n  notifyOnChanges(): void { (this.changes as EventEmitter<any>).emit(this); }\n\n  /** internal */\n  setDirty() { (this as{dirty: boolean}).dirty = true; }\n\n  /** internal */\n  destroy(): void {\n    (this.changes as EventEmitter<any>).complete();\n    (this.changes as EventEmitter<any>).unsubscribe();\n  }\n}\n\nfunction flatten<T>(list: Array<T|T[]>): T[] {\n  return list.reduce((flat: any[], item: T | T[]): T[] => {\n    const flatItem = Array.isArray(item) ? flatten(item) : item;\n    return (<T[]>flat).concat(flatItem);\n  }, []);\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {Injectable, Optional} from '../di';\n\nimport {Compiler} from './compiler';\nimport {NgModuleFactory} from './ng_module_factory';\nimport {NgModuleFactoryLoader} from './ng_module_factory_loader';\n\nconst _SEPARATOR = '#';\n\nconst FACTORY_CLASS_SUFFIX = 'NgFactory';\ndeclare var System: any;\n\n/**\n * Configuration for SystemJsNgModuleLoader.\n * token.\n *\n * @experimental\n */\nexport abstract class SystemJsNgModuleLoaderConfig {\n  /**\n   * Prefix to add when computing the name of the factory module for a given module name.\n   */\n  factoryPathPrefix: string;\n\n  /**\n   * Suffix to add when computing the name of the factory module for a given module name.\n   */\n  factoryPathSuffix: string;\n}\n\nconst DEFAULT_CONFIG: SystemJsNgModuleLoaderConfig = {\n  factoryPathPrefix: '',\n  factoryPathSuffix: '.ngfactory',\n};\n\n/**\n * NgModuleFactoryLoader that uses SystemJS to load NgModuleFactory\n * @experimental\n */\n@Injectable()\nexport class SystemJsNgModuleLoader implements NgModuleFactoryLoader {\n  private _config: SystemJsNgModuleLoaderConfig;\n\n  constructor(private _compiler: Compiler, @Optional() config?: SystemJsNgModuleLoaderConfig) {\n    this._config = config || DEFAULT_CONFIG;\n  }\n\n  load(path: string): Promise<NgModuleFactory<any>> {\n    const offlineMode = this._compiler instanceof Compiler;\n    return offlineMode ? this.loadFactory(path) : this.loadAndCompile(path);\n  }\n\n  private loadAndCompile(path: string): Promise<NgModuleFactory<any>> {\n    let [module, exportName] = path.split(_SEPARATOR);\n    if (exportName === undefined) {\n      exportName = 'default';\n    }\n\n    return System.import(module)\n        .then((module: any) => module[exportName])\n        .then((type: any) => checkNotEmpty(type, module, exportName))\n        .then((type: any) => this._compiler.compileModuleAsync(type));\n  }\n\n  private loadFactory(path: string): Promise<NgModuleFactory<any>> {\n    let [module, exportName] = path.split(_SEPARATOR);\n    let factoryClassSuffix = FACTORY_CLASS_SUFFIX;\n    if (exportName === undefined) {\n      exportName = 'default';\n      factoryClassSuffix = '';\n    }\n\n    return System.import(this._config.factoryPathPrefix + module + this._config.factoryPathSuffix)\n        .then((module: any) => module[exportName + factoryClassSuffix])\n        .then((factory: any) => checkNotEmpty(factory, module, exportName));\n  }\n}\n\nfunction checkNotEmpty(value: any, modulePath: string, exportName: string): any {\n  if (!value) {\n    throw new Error(`Cannot find '${exportName}' in '${modulePath}'`);\n  }\n  return value;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ElementRef} from '