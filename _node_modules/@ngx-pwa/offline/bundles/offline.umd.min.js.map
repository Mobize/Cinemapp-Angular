{"version":3,"file":"offline.umd.min.js","sources":["../../out-tsc/lib/src/tokens.ts","../../out-tsc/lib/src/network.service.ts","../../out-tsc/lib/src/online.guard.ts"],"sourcesContent":["import { InjectionToken, Provider } from '@angular/core';\n\nexport const OFFLINE_ROUTE_OFFLINE = new InjectionToken<string>('offline-config-route-offline', {\n  providedIn: 'root',\n  factory: () => '/offline'\n });\nexport const OFFLINE_ROUTE_UNAVAILABLE = new InjectionToken<string>('offline-config-route-unavailable', {\n  providedIn: 'root',\n  factory: () => '/unavailable'\n });\nexport const OFFLINE_GUARDS_REDIRECT = new InjectionToken<boolean>('offline-config-guards-redirect', {\n  providedIn: 'root',\n  factory: () => true\n });\n\nexport interface OfflineProvidersConfig {\n  /** Full URL of the page to redirect to when Internet connection is unavailable (default: '/offline') */\n  routeOffline?: string;\n  /** Full URL of the page to redirect to when the server is unavailable (default: '/unavailable') */\n  routeUnavailable?: string;\n  /**\n   * Tells guards to redirect to the offline page when Internet connection is unavailable (default: true)\n   * or to just block the navigation\n   */\n  guardsRedirect?: boolean;\n}\n\nexport function offlineProviders(config: OfflineProvidersConfig): Provider[] {\n\n  return [\n    config.routeOffline ? { provide: OFFLINE_ROUTE_OFFLINE, useValue: config.routeOffline }  : [],\n    config.routeUnavailable ? { provide: OFFLINE_ROUTE_UNAVAILABLE, useValue: config.routeUnavailable } : [],\n    config.guardsRedirect === false ? { provide: OFFLINE_GUARDS_REDIRECT, useValue: false } : [],\n  ];\n\n}\n","import { Injectable, Inject, PLATFORM_ID, Optional } from '@angular/core';\nimport { isPlatformBrowser } from '@angular/common';\nimport { Router } from '@angular/router';\nimport { Observable, fromEvent, of, merge, empty, OperatorFunction } from 'rxjs';\nimport { catchError, mapTo, startWith } from 'rxjs/operators';\n\nimport { OFFLINE_ROUTE_OFFLINE, OFFLINE_ROUTE_UNAVAILABLE } from './tokens';\n\n@Injectable({ providedIn: 'root' })\nexport class Network {\n\n  static instance: Network | null = null;\n\n  /** Observable to listen when Internet connection availability changes */\n  onlineChanges: Observable<boolean>;\n\n  /** Check if Internet connection is available */\n  get online(): boolean {\n    return isPlatformBrowser(this.platformId) ? navigator.onLine : true;\n  }\n\n  /** Do not use this method, use `catchOffline` function directly */\n  static catchOffline<T>() {\n\n    return catchError<T, T>(Network.catchCallback);\n\n  }\n\n  protected static catchCallback<T>(error: any, caught: Observable<T>): Observable<T> {\n\n    if (!Network.instance) {\n\n      console.log(`You need to import OfflineModule in your AppModule\n      AND to inject the Network service at least once, for example in your AppComponent constructor.`);\n\n      throw error;\n\n    } else if (!Network.instance.router) {\n\n      console.log(`You need to import RouterModule.forRoot([]) in your application.`);\n\n      throw error;\n\n    } else {\n\n      if (!Network.instance.online) {\n\n        Network.instance.router.navigate([Network.instance.routeOffline]);\n\n        return empty();\n\n      } else if (error.status && (error.status >= 500 && error.status < 600)) {\n\n        Network.instance.router.navigate([Network.instance.routeUnavailable]);\n\n        return empty();\n\n      } else {\n\n        throw error;\n\n      }\n\n    }\n\n  }\n\n  constructor(\n    @Optional() protected router: Router,\n    @Inject(PLATFORM_ID) protected platformId: string,\n    @Inject(OFFLINE_ROUTE_OFFLINE) protected routeOffline: string,\n    @Inject(OFFLINE_ROUTE_UNAVAILABLE) protected routeUnavailable: string,\n  ) {\n\n    /* Store instance in a static property to allow access to injected services in the RxJS static operator\n     * Should be done only once */\n    if (!Network.instance) {\n\n      Network.instance = this;\n\n    }\n\n    this.initOnlineObservable();\n\n  }\n\n  protected initOnlineObservable() {\n\n    this.onlineChanges = !isPlatformBrowser(this.platformId) ? of(true) : merge(\n      fromEvent(window, 'online').pipe(mapTo(true)),\n      fromEvent(window, 'offline').pipe(mapTo(false)),\n    )\n    .pipe(startWith(this.online));\n\n  }\n\n}\n\n/**\n * Catch offline errors (no Internet connection) and server errors (HTTP status 5xx)\n * and redirect to /offline or /unavailable page (routes can be changed in the OfflineModule)\n */\nexport const catchOffline = Network.catchOffline;\n","import { Injectable, Inject } from '@angular/core';\nimport { Router, CanActivate, CanActivateChild, CanLoad } from '@angular/router';\n\nimport { OFFLINE_ROUTE_OFFLINE, OFFLINE_GUARDS_REDIRECT } from './tokens';\nimport { Network } from './network.service';\n\n/**\n * Check if Internet connection is available to allow a navigation to a route or not.\n * By default, if Internet connection is not available, the user will be redirected to the /offline page.\n * This behavior and the URL of redirection can be configured in the OfflineModule.\n */\n@Injectable({ providedIn: 'root' })\nexport class OnlineGuard implements CanActivate, CanActivateChild, CanLoad {\n\n  constructor(\n    protected router: Router,\n    protected network: Network,\n    @Inject(OFFLINE_ROUTE_OFFLINE) protected routeOffline: string,\n    @Inject(OFFLINE_GUARDS_REDIRECT) protected guardsRedirect: boolean,\n  ) {}\n\n  canActivate() {\n    return this.guard();\n  }\n\n  canActivateChild() {\n    return this.guard();\n  }\n\n  canLoad() {\n    return this.guard();\n  }\n\n\n  protected guard(): boolean {\n\n    if (!this.network.online) {\n\n      if (this.guardsRedirect) {\n        this.router.navigate([this.routeOffline]);\n      }\n\n      return false;\n\n    }\n\n    return true;\n\n  }\n\n}\n"],"names":["OFFLINE_ROUTE_OFFLINE","InjectionToken","providedIn","factory","OFFLINE_ROUTE_UNAVAILABLE","OFFLINE_GUARDS_REDIRECT","router","platformId","routeOffline","routeUnavailable","this","Network","instance","initOnlineObservable","Object","isPlatformBrowser","navigator","onLine","catchError","catchCallback","error","caught","online","status","navigate","empty","console","log","onlineChanges","merge","fromEvent","window","pipe","mapTo","startWith","of","Injectable","Router","Optional","Inject","PLATFORM_ID","catchOffline","network","guardsRedirect","OnlineGuard","guard","config","provide","useValue"],"mappings":"gfAAA,IAEaA,EAAwB,IAAIC,iBAAuB,+BAAgC,CAC9FC,WAAY,OACZC,QAAS,WAAM,MAAA,cAEJC,EAA4B,IAAIH,iBAAuB,mCAAoC,CACtGC,WAAY,OACZC,QAAS,WAAM,MAAA,kBAEJE,EAA0B,IAAIJ,iBAAwB,iCAAkC,CACnGC,WAAY,OACZC,QAAS,WAAM,OAAA,KCZjB,iBAmEE,WACwBG,EACSC,EACUC,EACIC,GAHvBC,YAAAJ,EACSI,gBAAAH,EACUG,kBAAAF,EACIE,sBAAAD,EAKxCE,EAAQC,WAEXD,EAAQC,SAAWF,MAIrBA,KAAKG,8BAjEPC,sBAAIH,0BAAJ,WACE,OAAOI,oBAAkBL,KAAKH,aAAcS,UAAUC,wCAIjDN,eAAP,WAEE,OAAOO,aAAiBP,EAAQQ,gBAIjBR,gBAAjB,SAAkCS,EAAYC,GAE5C,GAAKV,EAAQC,SAON,CAAA,GAAKD,EAAQC,SAASN,OAMtB,CAEL,GAAKK,EAAQC,SAASU,OAMf,CAAA,GAAIF,EAAMG,QAA2B,KAAhBH,EAAMG,QAAiBH,EAAMG,OAAS,IAIhE,OAFAZ,EAAQC,SAASN,OAAOkB,SAAS,CAACb,EAAQC,SAASH,mBAE5CgB,UAIP,MAAML,EAVN,OAFAT,EAAQC,SAASN,OAAOkB,SAAS,CAACb,EAAQC,SAASJ,eAE5CiB,UART,MAFAC,QAAQC,IAAI,oEAENP,EANN,MAHAM,QAAQC,IAAI,4JAGNP,GAmDAT,iCAAV,WAEED,KAAKkB,cAAiBb,oBAAkBL,KAAKH,YAAyBsB,QACpEC,YAAUC,OAAQ,UAAUC,KAAKC,SAAM,IACvCH,YAAUC,OAAQ,WAAWC,KAAKC,SAAM,KAEzCD,KAAKE,YAAUxB,KAAKY,SAJsCa,MAAG,eA7E9B,yBAHnCC,mBAAW,CAAElC,WAAY,oDANjBmC,2BAkEJC,6CACAC,eAAOC,iDACPD,eAAOvC,qCACPuC,eAAOnC,sLA+BCqC,EAAe9B,EAAQ8B,0BCxFlC,WACYnC,EACAoC,EAC+BlC,EACEmC,GAHjCjC,YAAAJ,EACAI,aAAAgC,EAC+BhC,kBAAAF,EACEE,oBAAAiC,SAG7CC,wBAAA,WACE,OAAOlC,KAAKmC,SAGdD,6BAAA,WACE,OAAOlC,KAAKmC,SAGdD,oBAAA,WACE,OAAOlC,KAAKmC,SAIJD,kBAAV,WAEE,QAAKlC,KAAKgC,QAAQpB,SAEZZ,KAAKiC,gBACPjC,KAAKJ,OAAOkB,SAAS,CAACd,KAAKF,gBAGtB,wBA/BZ4B,mBAAW,CAAElC,WAAY,oDAVjBmC,gBAGA1B,kCAaJ4B,eAAOvC,qCACPuC,eAAOlC,2LFSZ,SAAiCyC,GAE/B,MAAO,CACLA,EAAOtC,aAAe,CAAEuC,QAAS/C,EAAuBgD,SAAUF,EAAOtC,cAAkB,GAC3FsC,EAAOrC,iBAAmB,CAAEsC,QAAS3C,EAA2B4C,SAAUF,EAAOrC,kBAAqB,IAC5E,IAA1BqC,EAAOH,eAA2B,CAAEI,QAAS1C,EAAyB2C,UAAU,GAAU"}